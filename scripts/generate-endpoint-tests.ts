#!/usr/bin/env npx tsx
/**
 * Generate endpoint tests from OpenAPI spec.
 *
 * This script parses the OpenAPI spec and generates vitest tests that verify:
 * - All endpoints have corresponding SDK methods
 * - Methods are properly typed
 */

import * as fs from 'fs';
import * as path from 'path';
import * as yaml from 'yaml';

interface OpenAPISpec {
  paths: Record<string, Record<string, OperationObject>>;
}

interface OperationObject {
  tags?: string[];
  operationId?: string;
  summary?: string;
  parameters?: ParameterObject[];
  requestBody?: object;
}

interface ParameterObject {
  name: string;
  in: string;
  required?: boolean;
  schema?: { type?: string };
}

// Map OpenAPI tags to SDK namespace names
const TAG_TO_RESOURCE: Record<string, string> = {
  'Posts': 'posts',
  'Accounts': 'accounts',
  'Profiles': 'profiles',
  'Analytics': 'analytics',
  'Account Groups': 'accountGroups',
  'Queue': 'queue',
  'Webhooks': 'webhooks',
  'API Keys': 'apiKeys',
  'Media': 'media',
  'Tools': 'tools',
  'Users': 'users',
  'Usage': 'usage',
  'Logs': 'logs',
  'Connect': 'connect',
  'Reddit Search': 'reddit',
  'Invites': 'invites',
  'GMB Reviews': 'accounts',
  'LinkedIn Mentions': 'accounts',
};

// Map operation IDs to their nested connect sub-resource paths
const CONNECT_NESTED_METHODS: Record<string, string> = {
  'listFacebookPages': 'connect.facebook',
  'selectFacebookPage': 'connect.facebook',
  'listGoogleBusinessLocations': 'connect.googleBusiness',
  'selectGoogleBusinessLocation': 'connect.googleBusiness',
  'listLinkedInOrganizations': 'connect.linkedin',
  'selectLinkedInOrganization': 'connect.linkedin',
  'listPinterestBoardsForSelection': 'connect.pinterest',
  'selectPinterestBoard': 'connect.pinterest',
  'listSnapchatProfiles': 'connect.snapchat',
  'selectSnapchatProfile': 'connect.snapchat',
  'connectBlueskyCredentials': 'connect.bluesky',
  'getTelegramConnectStatus': 'connect.telegram',
  'initiateTelegramConnect': 'connect.telegram',
  'completeTelegramConnect': 'connect.telegram',
};

interface Endpoint {
  resource: string;
  method: string;
  operationId: string;
  httpMethod: string;
  path: string;
  hasBody: boolean;
}

function loadOpenAPISpec(specPath: string): OpenAPISpec {
  const content = fs.readFileSync(specPath, 'utf-8');
  return yaml.parse(content);
}

function extractEndpoints(spec: OpenAPISpec): Endpoint[] {
  const endpoints: Endpoint[] = [];

  for (const [pathStr, pathItem] of Object.entries(spec.paths || {})) {
    for (const [method, operation] of Object.entries(pathItem)) {
      if (!['get', 'post', 'put', 'patch', 'delete'].includes(method)) {
        continue;
      }

      const tags = operation.tags || [];
      if (tags.length === 0) continue;

      const tag = tags[0];
      if (!(tag in TAG_TO_RESOURCE)) continue;

      let resourceName = TAG_TO_RESOURCE[tag];
      const operationId = operation.operationId || '';
      if (!operationId) continue;

      // Check if this is a nested connect method
      if (operationId in CONNECT_NESTED_METHODS) {
        resourceName = CONNECT_NESTED_METHODS[operationId];
      }

      endpoints.push({
        resource: resourceName,
        method: operationId,
        operationId,
        httpMethod: method.toUpperCase(),
        path: pathStr,
        hasBody: 'requestBody' in operation,
      });
    }
  }

  return endpoints;
}

function generateTestFile(endpoints: Endpoint[]): string {
  const lines: string[] = [
    '/**',
    ' * Auto-generated endpoint tests from OpenAPI spec.',
    ' *',
    ' * DO NOT EDIT THIS FILE MANUALLY.',
    ' * Run `npx tsx scripts/generate-endpoint-tests.ts` to regenerate.',
    ' */',
    '',
    "import { describe, it, expect } from 'vitest';",
    "import Late from '../src';",
    '',
    "describe('Endpoint Methods', () => {",
    '  const client = new Late({ apiKey: "test_key" });',
    '',
  ];

  // Group endpoints by resource
  const byResource: Record<string, Endpoint[]> = {};
  for (const endpoint of endpoints) {
    if (!(endpoint.resource in byResource)) {
      byResource[endpoint.resource] = [];
    }
    byResource[endpoint.resource].push(endpoint);
  }

  // Generate tests for each resource
  for (const [resource, resourceEndpoints] of Object.entries(byResource).sort()) {
    const displayName = resource.replace(/([A-Z])/g, ' $1').trim();
    lines.push(`  describe('${displayName}', () => {`);

    for (const endpoint of resourceEndpoints) {
      lines.push(`    it('should have ${endpoint.method} method', () => {`);
      lines.push(`      expect(client.${resource}.${endpoint.method}).toBeDefined();`);
      lines.push(`      expect(client.${resource}.${endpoint.method}).toBeTypeOf('function');`);
      lines.push('    });');
      lines.push('');
    }

    lines.push('  });');
    lines.push('');
  }

  lines.push('});');

  return lines.join('\n');
}

function main(): void {
  const scriptDir = path.dirname(new URL(import.meta.url).pathname);
  const specPath = path.join(scriptDir, '..', 'openapi.yaml');
  const outputPath = path.join(scriptDir, '..', 'tests', 'endpoints.test.ts');

  const spec = loadOpenAPISpec(specPath);
  const endpoints = extractEndpoints(spec);
  const testContent = generateTestFile(endpoints);

  if (process.argv.includes('--print')) {
    console.log(testContent);
  } else {
    fs.writeFileSync(outputPath, testContent);
    console.log(`Generated ${outputPath}`);
    console.log(`Total endpoints: ${endpoints.length}`);
  }
}

main();
