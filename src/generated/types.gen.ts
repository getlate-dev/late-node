// This file is auto-generated by @hey-api/openapi-ts

export type AccountGetResponse = {
    account?: SocialAccount;
};

export type AccountsListResponse = {
    accounts?: Array<SocialAccount>;
    /**
     * Whether user has analytics add-on access
     */
    hasAnalyticsAccess?: boolean;
};

export type AccountWithFollowerStats = SocialAccount & {
    profilePicture?: string;
    /**
     * Current follower count
     */
    currentFollowers?: number;
    lastUpdated?: string;
    /**
     * Follower change over period
     */
    growth?: number;
    /**
     * Percentage growth
     */
    growthPercentage?: number;
    /**
     * Number of historical snapshots
     */
    dataPoints?: number;
};

export type AnalyticsListResponse = {
    overview?: AnalyticsOverview;
    posts?: Array<{
        _id?: string;
        content?: string;
        scheduledFor?: string;
        publishedAt?: string;
        status?: string;
        analytics?: PostAnalytics;
        platforms?: Array<PlatformAnalytics>;
        platform?: string;
        platformPostUrl?: string;
        isExternal?: boolean;
        thumbnailUrl?: string;
        mediaType?: 'image' | 'video' | 'gif' | 'document';
        mediaItems?: Array<MediaItem>;
    }>;
    pagination?: Pagination;
    /**
     * Connected social accounts (followerCount and followersLastUpdated only included if user has analytics add-on)
     */
    accounts?: Array<SocialAccount>;
    /**
     * Whether user has analytics add-on access
     */
    hasAnalyticsAccess?: boolean;
};

export type AnalyticsOverview = {
    totalPosts?: number;
    publishedPosts?: number;
    scheduledPosts?: number;
    lastSync?: string;
};

export type AnalyticsSinglePostResponse = {
    postId?: string;
    status?: string;
    content?: string;
    scheduledFor?: string;
    publishedAt?: string;
    analytics?: PostAnalytics;
    platformAnalytics?: Array<PlatformAnalytics>;
    platform?: string;
    platformPostUrl?: string;
    isExternal?: boolean;
};

export type ApiKey = {
    id?: string;
    name?: string;
    keyPreview?: string;
    expiresAt?: string;
    createdAt?: string;
    /**
     * Returned only once, on creation
     */
    key?: string;
    /**
     * 'full' grants access to all profiles, 'profiles' restricts to specific profiles
     */
    scope?: 'full' | 'profiles';
    /**
     * Profiles this key can access (populated with name and color). Only present when scope is 'profiles'.
     */
    profileIds?: Array<{
        _id?: string;
        name?: string;
        color?: string;
    }>;
    /**
     * 'read-write' allows all operations, 'read' restricts to GET requests only
     */
    permission?: 'read-write' | 'read';
};

/**
 * 'full' grants access to all profiles, 'profiles' restricts to specific profiles
 */
export type scope = 'full' | 'profiles';

/**
 * 'read-write' allows all operations, 'read' restricts to GET requests only
 */
export type permission = 'read-write' | 'read';

/**
 * Bluesky post settings. Supports text posts with up to 4 images or a single video. threadItems creates a reply chain (Bluesky thread). Images exceeding 1MB are automatically compressed. Alt text supported via mediaItem properties.
 *
 */
export type BlueskyPlatformData = {
    /**
     * Sequence of posts in a Bluesky thread (root then replies in order).
     */
    threadItems?: Array<{
        content?: string;
        mediaItems?: Array<MediaItem>;
    }>;
};

export type CaptionResponse = {
    caption?: string;
};

/**
 * Connection event log showing account connection/disconnection history
 */
export type ConnectionLog = {
    _id?: string;
    /**
     * User who owns the connection (may be null for early OAuth failures)
     */
    userId?: string;
    profileId?: string;
    /**
     * The social account ID (present on successful connections and disconnects)
     */
    accountId?: string;
    platform?: 'tiktok' | 'instagram' | 'facebook' | 'youtube' | 'linkedin' | 'twitter' | 'threads' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat';
    /**
     * Type of connection event: connect_success, connect_failed, disconnect, reconnect_success, reconnect_failed
     */
    eventType?: 'connect_success' | 'connect_failed' | 'disconnect' | 'reconnect_success' | 'reconnect_failed';
    /**
     * How the connection was initiated
     */
    connectionMethod?: 'oauth' | 'credentials' | 'invitation';
    /**
     * Error details (present on failed events)
     */
    error?: {
        /**
         * Error code (e.g., oauth_denied, token_exchange_failed)
         */
        code?: string;
        /**
         * Human-readable error message
         */
        message?: string;
        /**
         * Raw error response (truncated to 2000 chars)
         */
        rawResponse?: string;
    };
    /**
     * Success details (present on successful events)
     */
    success?: {
        displayName?: string;
        username?: string;
        profilePicture?: string;
        /**
         * OAuth scopes/permissions granted
         */
        permissions?: Array<(string)>;
        tokenExpiresAt?: string;
        /**
         * Account type (personal, business, organization)
         */
        accountType?: string;
    };
    /**
     * Additional context about the connection attempt
     */
    context?: {
        isHeadlessMode?: boolean;
        hasCustomRedirectUrl?: boolean;
        isReconnection?: boolean;
        /**
         * Using bring-your-own-keys
         */
        isBYOK?: boolean;
        invitationToken?: string;
        connectToken?: string;
    };
    /**
     * How long the operation took in milliseconds
     */
    durationMs?: number;
    /**
     * Additional metadata
     */
    metadata?: {
        [key: string]: unknown;
    };
    createdAt?: string;
};

export type platform = 'tiktok' | 'instagram' | 'facebook' | 'youtube' | 'linkedin' | 'twitter' | 'threads' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat';

/**
 * Type of connection event: connect_success, connect_failed, disconnect, reconnect_success, reconnect_failed
 */
export type eventType = 'connect_success' | 'connect_failed' | 'disconnect' | 'reconnect_success' | 'reconnect_failed';

/**
 * How the connection was initiated
 */
export type connectionMethod = 'oauth' | 'credentials' | 'invitation';

export type DownloadFormat = {
    formatId?: string;
    ext?: string;
    resolution?: string;
    filesize?: number;
    quality?: string;
};

export type DownloadResponse = {
    url?: string;
    title?: string;
    thumbnail?: string;
    duration?: number;
    formats?: Array<DownloadFormat>;
};

export type ErrorResponse = {
    error?: string;
    details?: {
        [key: string]: unknown;
    };
};

/**
 * Feed posts support up to 10 images (no mixed video+image). Stories require single media (24h, no captions). Reels require single vertical video (9:16, 3-60s).
 */
export type FacebookPlatformData = {
    /**
     * Set to 'story' for Page Stories (24h ephemeral) or 'reel' for Reels (short vertical video). Defaults to feed post if omitted.
     */
    contentType?: 'story' | 'reel';
    /**
     * Reel title (only for contentType=reel). Separate from the caption/content field.
     */
    title?: string;
    /**
     * Optional first comment to post immediately after publishing (feed posts only, not stories or reels)
     */
    firstComment?: string;
    /**
     * Target Facebook Page ID for multi-page posting. If omitted, uses the default page. Use GET /v1/accounts/{id}/facebook-page to list pages.
     */
    pageId?: string;
};

/**
 * Set to 'story' for Page Stories (24h ephemeral) or 'reel' for Reels (short vertical video). Defaults to feed post if omitted.
 */
export type contentType = 'story' | 'reel';

export type FollowerStatsResponse = {
    accounts?: Array<AccountWithFollowerStats>;
    dateRange?: {
        from?: string;
        to?: string;
    };
    aggregation?: 'daily' | 'weekly' | 'monthly';
};

export type aggregation = 'daily' | 'weekly' | 'monthly';

export type FoodMenu = {
    labels: Array<FoodMenuLabel>;
    sections?: Array<FoodMenuSection>;
    /**
     * Cuisine types (e.g. AMERICAN, ITALIAN, JAPANESE)
     */
    cuisines?: Array<(string)>;
    /**
     * URL of the original menu source
     */
    sourceUrl?: string;
};

export type FoodMenuItem = {
    labels: Array<FoodMenuLabel>;
    attributes?: FoodMenuItemAttributes;
    /**
     * Item variants/options (e.g. sizes, preparations)
     */
    options?: Array<{
        labels?: Array<FoodMenuLabel>;
        attributes?: FoodMenuItemAttributes;
    }>;
};

export type FoodMenuItemAttributes = {
    price?: Money;
    /**
     * Spiciness level (e.g. MILD, MEDIUM, HOT)
     */
    spiciness?: string;
    /**
     * Allergens (e.g. DAIRY, GLUTEN, SHELLFISH)
     */
    allergen?: Array<(string)>;
    /**
     * Dietary labels (e.g. VEGETARIAN, VEGAN, GLUTEN_FREE)
     */
    dietaryRestriction?: Array<(string)>;
    /**
     * Number of people the item serves
     */
    servesNumPeople?: number;
    /**
     * Preparation methods (e.g. GRILLED, FRIED)
     */
    preparationMethods?: Array<(string)>;
    /**
     * Media references for item photos
     */
    mediaKeys?: Array<(string)>;
};

export type FoodMenuLabel = {
    /**
     * Display name of the item/section/menu
     */
    displayName: string;
    /**
     * Optional description
     */
    description?: string;
    /**
     * BCP-47 language code (e.g. en, es)
     */
    languageCode?: string;
};

export type FoodMenuSection = {
    labels: Array<FoodMenuLabel>;
    items?: Array<FoodMenuItem>;
};

/**
 * Text and single image only (no videos). Optional call-to-action button. Posts appear on GBP, Google Search, and Maps. Use locationId for multi-location posting.
 */
export type GoogleBusinessPlatformData = {
    /**
     * Target GBP location ID (e.g. "locations/123456789"). If omitted, uses the default location. Use GET /v1/accounts/{id}/gmb-locations to list locations.
     */
    locationId?: string;
    /**
     * BCP 47 language code (e.g. "en", "de", "es"). Auto-detected if omitted. Set explicitly for short or mixed-language posts.
     */
    languageCode?: string;
    /**
     * Optional call-to-action button displayed on the post
     */
    callToAction?: {
        /**
         * Button action type: LEARN_MORE, BOOK, ORDER, SHOP, SIGN_UP, CALL
         */
        type: 'LEARN_MORE' | 'BOOK' | 'ORDER' | 'SHOP' | 'SIGN_UP' | 'CALL';
        /**
         * Destination URL for the CTA button (required when callToAction is provided)
         */
        url: string;
    };
};

/**
 * Button action type: LEARN_MORE, BOOK, ORDER, SHOP, SIGN_UP, CALL
 */
export type type = 'LEARN_MORE' | 'BOOK' | 'ORDER' | 'SHOP' | 'SIGN_UP' | 'CALL';

export type HashtagCheckResponse = {
    hashtags?: Array<HashtagInfo>;
};

export type HashtagInfo = {
    hashtag?: string;
    status?: 'safe' | 'banned' | 'restricted' | 'unknown';
    postCount?: number;
};

export type status = 'safe' | 'banned' | 'restricted' | 'unknown';

/**
 * Feed aspect ratio 0.8-1.91, carousels up to 10 items, stories require media (no captions). User tag coordinates 0.0-1.0 from top-left. Images over 8 MB and videos over platform limits are auto-compressed.
 */
export type InstagramPlatformData = {
    /**
     * Set to 'story' to publish as a Story. Default posts become Reels or feed depending on media.
     */
    contentType?: 'story';
    /**
     * For Reels only. When true (default), the Reel appears on both the Reels tab and your main profile feed. Set to false to post to the Reels tab only.
     */
    shareToFeed?: boolean;
    /**
     * Up to 3 Instagram usernames to invite as collaborators (feed/Reels only)
     */
    collaborators?: Array<(string)>;
    /**
     * Optional first comment to add after the post is created (not applied to Stories)
     */
    firstComment?: string;
    /**
     * Trial Reels configuration. Trial reels are shared to non-followers first and can later be graduated to regular reels manually or automatically based on performance. Only applies to Reels.
     */
    trialParams?: {
        /**
         * MANUAL (graduate from Instagram app) or SS_PERFORMANCE (auto-graduate if performs well with non-followers)
         */
        graduationStrategy?: 'MANUAL' | 'SS_PERFORMANCE';
    };
    /**
     * Tag Instagram users in photos by username and position. Not supported for stories or videos. For carousels, use mediaIndex to target specific slides (defaults to 0). Tags on video items are silently skipped.
     */
    userTags?: Array<{
        /**
         * Instagram username (@ symbol is optional and will be removed automatically)
         */
        username: string;
        /**
         * X coordinate position from left edge (0.0 = left, 0.5 = center, 1.0 = right)
         */
        x: number;
        /**
         * Y coordinate position from top edge (0.0 = top, 0.5 = center, 1.0 = bottom)
         */
        y: number;
        /**
         * Zero-based index of the carousel item to tag. Defaults to 0. Tags on video items or out-of-range indices are ignored.
         */
        mediaIndex?: number;
    }>;
    /**
     * Custom name for original audio in Reels. Replaces the default "Original Audio" label. Can only be set once.
     */
    audioName?: string;
    /**
     * Millisecond offset from video start for the Reel thumbnail. Ignored if a custom thumbnail URL is provided. Defaults to 0.
     */
    thumbOffset?: number;
};

/**
 * Set to 'story' to publish as a Story. Default posts become Reels or feed depending on media.
 */
export type contentType2 = 'story';

/**
 * MANUAL (graduate from Instagram app) or SS_PERFORMANCE (auto-graduate if performs well with non-followers)
 */
export type graduationStrategy = 'MANUAL' | 'SS_PERFORMANCE';

/**
 * Response for DAILY aggregation (time series breakdown)
 */
export type LinkedInAggregateAnalyticsDailyResponse = {
    accountId?: string;
    platform?: string;
    accountType?: string;
    username?: string;
    aggregation?: 'DAILY';
    dateRange?: {
        startDate?: string;
        endDate?: string;
    } | null;
    /**
     * Daily breakdown of each metric as date/count pairs. Reach not available with DAILY aggregation.
     */
    analytics?: {
        impressions?: Array<{
            date?: string;
            count?: number;
        }>;
        reactions?: Array<{
            date?: string;
            count?: number;
        }>;
        comments?: Array<{
            date?: string;
            count?: number;
        }>;
        shares?: Array<{
            date?: string;
            count?: number;
        }>;
    };
    /**
     * Metrics that were skipped due to API limitations
     */
    skippedMetrics?: Array<(string)>;
    note?: string;
    lastUpdated?: string;
};

export type aggregation2 = 'DAILY';

/**
 * Response for TOTAL aggregation (lifetime totals)
 */
export type LinkedInAggregateAnalyticsTotalResponse = {
    accountId?: string;
    platform?: string;
    accountType?: string;
    username?: string;
    aggregation?: 'TOTAL';
    dateRange?: {
        startDate?: string;
        endDate?: string;
    } | null;
    analytics?: {
        /**
         * Total impressions across all posts
         */
        impressions?: number;
        /**
         * Unique members reached across all posts
         */
        reach?: number;
        /**
         * Total reactions across all posts
         */
        reactions?: number;
        /**
         * Total comments across all posts
         */
        comments?: number;
        /**
         * Total reshares across all posts
         */
        shares?: number;
        /**
         * Overall engagement rate as percentage
         */
        engagementRate?: number;
    };
    note?: string;
    lastUpdated?: string;
};

export type aggregation3 = 'TOTAL';

/**
 * Up to 20 images, no multi-video. Single PDF supported (max 100MB). Link previews auto-generated when no media attached. Use organizationUrn for multi-org posting.
 */
export type LinkedInPlatformData = {
    /**
     * Title displayed on LinkedIn document (PDF/carousel) posts. Required by LinkedIn for document posts. If omitted, falls back to the media item title, then the filename.
     */
    documentTitle?: string;
    /**
     * Target LinkedIn Organization URN (e.g. "urn:li:organization:123456789"). If omitted, uses the default org. Use GET /v1/accounts/{id}/linkedin-organizations to list orgs.
     */
    organizationUrn?: string;
    /**
     * Optional first comment to add after the post is created
     */
    firstComment?: string;
    /**
     * Set to true to disable automatic link previews for URLs in the post content (default is false)
     */
    disableLinkPreview?: boolean;
};

/**
 * Media referenced in posts. URLs must be publicly reachable over HTTPS. Use POST /v1/media/presign for uploads up to 5GB. Late auto-compresses images and videos that exceed platform limits (videos over 200 MB may not be compressed).
 */
export type MediaItem = {
    type?: 'image' | 'video' | 'gif' | 'document';
    url?: string;
    /**
     * Optional title for the media item. Used as the document title for LinkedIn PDF/carousel posts. If omitted, falls back to the post title, then the filename.
     */
    title?: string;
    filename?: string;
    /**
     * Optional file size in bytes
     */
    size?: number;
    /**
     * Optional MIME type (e.g. image/jpeg, video/mp4)
     */
    mimeType?: string;
    /**
     * Optional thumbnail image URL for videos
     */
    thumbnail?: string;
    /**
     * Optional custom cover image URL for Instagram Reels
     */
    instagramThumbnail?: string;
    /**
     * Internal flag indicating the image was resized for TikTok
     */
    tiktokProcessed?: boolean;
};

export type type2 = 'image' | 'video' | 'gif' | 'document';

export type MediaUploadResponse = {
    files?: Array<UploadedFile>;
};

export type Money = {
    /**
     * ISO 4217 currency code (e.g. USD, EUR)
     */
    currencyCode: string;
    /**
     * Whole units of the amount
     */
    units: string;
    /**
     * Nano units (10^-9) of the amount
     */
    nanos?: number;
};

export type Pagination = {
    page?: number;
    limit?: number;
    total?: number;
    pages?: number;
};

/**
 * Page size
 */
export type ParameterLimitParam = number;

/**
 * Page number (1-based)
 */
export type ParameterPageParam = number;

export type PinterestPlatformData = {
    /**
     * Pin title. Defaults to first line of content or "Pin". Must be ≤ 100 characters.
     */
    title?: string;
    /**
     * Target Pinterest board ID. If omitted, the first available board is used.
     */
    boardId?: string;
    /**
     * Destination link (pin URL)
     */
    link?: string;
    /**
     * Optional cover image for video pins
     */
    coverImageUrl?: string;
    /**
     * Optional key frame time in seconds for derived video cover
     */
    coverImageKeyFrameTime?: number;
};

export type PlatformAnalytics = {
    platform?: string;
    status?: string;
    accountId?: string;
    accountUsername?: string;
    analytics?: PostAnalytics;
    accountMetrics?: {
        /**
         * Followers/fans count (e.g., Instagram, Facebook Pages, Twitter)
         */
        followers?: (number) | null;
        /**
         * Subscribers count (e.g., YouTube)
         */
        subscribers?: (number) | null;
        lastUpdated?: (string) | null;
    } | null;
};

export type PlatformTarget = {
    /**
     * Supported values: twitter, threads, instagram, youtube, facebook, linkedin, pinterest, reddit, tiktok, bluesky, googlebusiness, telegram
     */
    platform?: string;
    accountId?: (string | SocialAccount);
    /**
     * Platform-specific text override. When set, this content is used instead of the top-level post content for this platform. Useful for tailoring captions per platform (e.g. keeping tweets under 280 characters).
     */
    customContent?: string;
    customMedia?: Array<MediaItem>;
    /**
     * Optional per-platform scheduled time override (uses post.scheduledFor when omitted)
     */
    scheduledFor?: string;
    /**
     * Platform-specific overrides and options.
     */
    platformSpecificData?: (TwitterPlatformData | ThreadsPlatformData | FacebookPlatformData | InstagramPlatformData | LinkedInPlatformData | PinterestPlatformData | YouTubePlatformData | GoogleBusinessPlatformData | TikTokPlatformData | TelegramPlatformData | SnapchatPlatformData | RedditPlatformData | BlueskyPlatformData);
    /**
     * Platform-specific status: pending, publishing, published, failed
     */
    status?: string;
    /**
     * The native post ID on the platform (populated after successful publish)
     */
    platformPostId?: string;
    /**
     * Public URL of the published post. Included in the response for immediate posts; for scheduled posts, fetch via GET /v1/posts/{postId} after publish time.
     */
    platformPostUrl?: string;
    /**
     * Timestamp when the post was published to this platform
     */
    publishedAt?: string;
    /**
     * Human-readable error message when status is failed. Contains platform-specific error details explaining why the publish failed.
     */
    errorMessage?: string;
    /**
     * Error category for programmatic handling: auth_expired (token expired/revoked), user_content (wrong format/too long), user_abuse (rate limits/spam), account_issue (config problems), platform_rejected (policy violation), platform_error (5xx/maintenance), system_error (Late infra), unknown
     */
    errorCategory?: 'auth_expired' | 'user_content' | 'user_abuse' | 'account_issue' | 'platform_rejected' | 'platform_error' | 'system_error' | 'unknown';
    /**
     * Who caused the error: user (fix content/reconnect), platform (outage/API change), system (Late issue, rare)
     */
    errorSource?: 'user' | 'platform' | 'system';
};

/**
 * Error category for programmatic handling: auth_expired (token expired/revoked), user_content (wrong format/too long), user_abuse (rate limits/spam), account_issue (config problems), platform_rejected (policy violation), platform_error (5xx/maintenance), system_error (Late infra), unknown
 */
export type errorCategory = 'auth_expired' | 'user_content' | 'user_abuse' | 'account_issue' | 'platform_rejected' | 'platform_error' | 'system_error' | 'unknown';

/**
 * Who caused the error: user (fix content/reconnect), platform (outage/API change), system (Late issue, rare)
 */
export type errorSource = 'user' | 'platform' | 'system';

export type Post = {
    _id?: string;
    userId?: (string | User);
    /**
     * YouTube: title must be ≤ 100 characters.
     *
     */
    title?: string;
    content?: string;
    mediaItems?: Array<MediaItem>;
    platforms?: Array<PlatformTarget>;
    scheduledFor?: string;
    timezone?: string;
    status?: 'draft' | 'scheduled' | 'publishing' | 'published' | 'failed' | 'partial';
    /**
     * YouTube constraints: each tag max 100 chars, combined max 500 chars, duplicates removed.
     */
    tags?: Array<(string)>;
    hashtags?: Array<(string)>;
    mentions?: Array<(string)>;
    visibility?: 'public' | 'private' | 'unlisted';
    metadata?: {
        [key: string]: unknown;
    };
    /**
     * Profile ID if the post was scheduled via the queue
     */
    queuedFromProfile?: string;
    /**
     * Queue ID if the post was scheduled via a specific queue
     */
    queueId?: string;
    createdAt?: string;
    updatedAt?: string;
};

export type status2 = 'draft' | 'scheduled' | 'publishing' | 'published' | 'failed' | 'partial';

export type visibility = 'public' | 'private' | 'unlisted';

export type PostAnalytics = {
    impressions?: number;
    reach?: number;
    likes?: number;
    comments?: number;
    shares?: number;
    /**
     * Number of saves/bookmarks (Instagram, Pinterest)
     */
    saves?: number;
    clicks?: number;
    views?: number;
    engagementRate?: number;
    lastUpdated?: string;
};

export type PostCreateResponse = {
    message?: string;
    post?: Post;
};

export type PostDeleteResponse = {
    message?: string;
};

export type PostGetResponse = {
    post?: Post;
};

/**
 * Publishing log entry showing details of a post publishing attempt
 */
export type PostLog = {
    _id?: string;
    postId?: (string | {
    _id?: string;
    content?: string;
    status?: string;
});
    userId?: string;
    profileId?: string;
    platform?: 'tiktok' | 'instagram' | 'facebook' | 'youtube' | 'linkedin' | 'twitter' | 'threads' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat';
    accountId?: string;
    accountUsername?: string;
    /**
     * Type of action logged: publish (initial attempt), retry (after failure), media_upload, rate_limit_pause, token_refresh, cancelled
     */
    action?: 'publish' | 'retry' | 'media_upload' | 'rate_limit_pause' | 'token_refresh' | 'cancelled';
    status?: 'success' | 'failed' | 'pending' | 'skipped';
    /**
     * HTTP status code from platform API
     */
    statusCode?: number;
    /**
     * Platform API endpoint called
     */
    endpoint?: string;
    request?: {
        /**
         * First 200 chars of caption
         */
        contentPreview?: string;
        mediaCount?: number;
        mediaTypes?: Array<(string)>;
        /**
         * URLs of media items sent to platform
         */
        mediaUrls?: Array<(string)>;
        scheduledFor?: string;
        /**
         * Full request body JSON (max 5000 chars)
         */
        rawBody?: string;
    };
    response?: {
        /**
         * ID returned by platform on success
         */
        platformPostId?: string;
        /**
         * URL of published post
         */
        platformPostUrl?: string;
        /**
         * Error message on failure
         */
        errorMessage?: string;
        /**
         * Platform-specific error code
         */
        errorCode?: string;
        /**
         * Full response body JSON (max 5000 chars)
         */
        rawBody?: string;
    };
    /**
     * How long the operation took in milliseconds
     */
    durationMs?: number;
    /**
     * Attempt number (1 for first try, 2+ for retries)
     */
    attemptNumber?: number;
    createdAt?: string;
};

/**
 * Type of action logged: publish (initial attempt), retry (after failure), media_upload, rate_limit_pause, token_refresh, cancelled
 */
export type action = 'publish' | 'retry' | 'media_upload' | 'rate_limit_pause' | 'token_refresh' | 'cancelled';

export type status3 = 'success' | 'failed' | 'pending' | 'skipped';

export type PostRetryResponse = {
    message?: string;
    post?: Post;
};

export type PostsListResponse = {
    posts?: Array<Post>;
    pagination?: Pagination;
};

export type PostUpdateResponse = {
    message?: string;
    post?: Post;
};

export type Profile = {
    _id?: string;
    userId?: string;
    name?: string;
    description?: string;
    color?: string;
    isDefault?: boolean;
    /**
     * Only present when includeOverLimit=true. Indicates if this profile exceeds the plan limit.
     */
    isOverLimit?: boolean;
    createdAt?: string;
};

export type ProfileCreateResponse = {
    message?: string;
    profile?: Profile;
};

export type ProfileDeleteResponse = {
    message?: string;
};

export type ProfileGetResponse = {
    profile?: Profile;
};

export type ProfilesListResponse = {
    profiles?: Array<Profile>;
};

export type ProfileUpdateResponse = {
    message?: string;
    profile?: Profile;
};

export type QueueDeleteResponse = {
    success?: boolean;
    deleted?: boolean;
};

export type QueueNextSlotResponse = {
    profileId?: string;
    nextSlot?: string;
    timezone?: string;
};

export type QueuePreviewResponse = {
    profileId?: string;
    count?: number;
    slots?: Array<(string)>;
};

export type QueueSchedule = {
    /**
     * Unique queue identifier
     */
    _id?: string;
    /**
     * Profile ID this queue belongs to
     */
    profileId?: string;
    /**
     * Queue name (e.g., "Morning Posts", "Evening Content")
     */
    name?: string;
    /**
     * IANA timezone (e.g., America/New_York)
     */
    timezone?: string;
    slots?: Array<QueueSlot>;
    /**
     * Whether the queue is active
     */
    active?: boolean;
    /**
     * Whether this is the default queue for the profile (used when no queueId specified)
     */
    isDefault?: boolean;
    createdAt?: string;
    updatedAt?: string;
};

export type QueueSlot = {
    /**
     * Day of week (0=Sunday, 6=Saturday)
     */
    dayOfWeek?: number;
    /**
     * Time in HH:mm format (24-hour)
     */
    time?: string;
};

export type QueueSlotsResponse = {
    exists?: boolean;
    schedule?: QueueSchedule;
    nextSlots?: Array<(string)>;
};

export type QueueUpdateResponse = {
    success?: boolean;
    schedule?: QueueSchedule;
    nextSlots?: Array<(string)>;
    reshuffledCount?: number;
};

/**
 * Posts are either link (with URL/media) or self (text-only). Use forceSelf to override. Subreddit defaults to the account's configured one. Some subreddits require a flair.
 */
export type RedditPlatformData = {
    /**
     * Target subreddit name (without "r/" prefix). Overrides the default. Use GET /v1/accounts/{id}/reddit-subreddits to list options.
     */
    subreddit?: string;
    /**
     * Post title. Defaults to the first line of content, truncated to 300 characters.
     */
    title?: string;
    /**
     * URL for link posts. If provided (and forceSelf is not true), creates a link post instead of a text post.
     */
    url?: string;
    /**
     * When true, creates a text/self post even when a URL or media is provided.
     */
    forceSelf?: boolean;
    /**
     * Flair ID for the post. Required by some subreddits. Use GET /v1/accounts/{id}/reddit-flairs?subreddit=name to list flairs.
     */
    flairId?: string;
};

/**
 * Requires a Public Profile. Single media item only. Content types: story (ephemeral 24h), saved_story (permanent, title max 45 chars), spotlight (video, max 160 chars).
 */
export type SnapchatPlatformData = {
    /**
     * Content type: story (ephemeral 24h, default), saved_story (permanent on Public Profile), spotlight (video feed)
     */
    contentType?: 'story' | 'saved_story' | 'spotlight';
};

/**
 * Content type: story (ephemeral 24h, default), saved_story (permanent on Public Profile), spotlight (video feed)
 */
export type contentType3 = 'story' | 'saved_story' | 'spotlight';

export type SocialAccount = {
    _id?: string;
    platform?: string;
    profileId?: (string | Profile);
    username?: string;
    displayName?: string;
    /**
     * Full profile URL for the connected account on its platform.
     */
    profileUrl?: string;
    isActive?: boolean;
    /**
     * Follower count (only included if user has analytics add-on)
     */
    followersCount?: number;
    /**
     * Last time follower count was updated (only included if user has analytics add-on)
     */
    followersLastUpdated?: string;
};

/**
 * Text, images (up to 10), videos (up to 10), and mixed media albums. Captions up to 1024 chars for media, 4096 for text-only.
 */
export type TelegramPlatformData = {
    /**
     * Text formatting mode for the message (default is HTML)
     */
    parseMode?: 'HTML' | 'Markdown' | 'MarkdownV2';
    /**
     * Disable link preview generation for URLs in the message
     */
    disableWebPagePreview?: boolean;
    /**
     * Send the message silently (users will receive notification without sound)
     */
    disableNotification?: boolean;
    /**
     * Protect message content from forwarding and saving
     */
    protectContent?: boolean;
};

/**
 * Text formatting mode for the message (default is HTML)
 */
export type parseMode = 'HTML' | 'Markdown' | 'MarkdownV2';

/**
 * Up to 10 images per carousel (no videos). Videos must be H.264/AAC MP4, max 5 min. Images JPEG/PNG, max 8 MB. Use threadItems for reply chains.
 */
export type ThreadsPlatformData = {
    /**
     * Sequence of posts in a Threads thread (root then replies in order).
     */
    threadItems?: Array<{
        content?: string;
        mediaItems?: Array<MediaItem>;
    }>;
};

/**
 * Photo carousels up to 35 images. Video titles up to 2200 chars, photo titles truncated to 90 chars. privacyLevel must match creator_info options. Both camelCase and snake_case accepted.
 */
export type TikTokPlatformData = {
    /**
     * When true, sends the post to the TikTok Creator Inbox as a draft instead of publishing immediately.
     */
    draft?: boolean;
    /**
     * One of the values returned by the TikTok creator info API for the account
     */
    privacyLevel?: string;
    /**
     * Allow comments on the post
     */
    allowComment?: boolean;
    /**
     * Allow duets (required for video posts)
     */
    allowDuet?: boolean;
    /**
     * Allow stitches (required for video posts)
     */
    allowStitch?: boolean;
    /**
     * Type of commercial content disclosure
     */
    commercialContentType?: 'none' | 'brand_organic' | 'brand_content';
    /**
     * Whether the post promotes a brand partner
     */
    brandPartnerPromote?: boolean;
    /**
     * Whether the post is a brand organic post
     */
    isBrandOrganicPost?: boolean;
    /**
     * User has confirmed they previewed the content
     */
    contentPreviewConfirmed?: boolean;
    /**
     * User has given express consent for posting
     */
    expressConsentGiven?: boolean;
    /**
     * Optional override. Defaults based on provided media items.
     */
    mediaType?: 'video' | 'photo';
    /**
     * Optional for video posts. Timestamp in milliseconds to select which frame to use as thumbnail (defaults to 1000ms/1 second).
     */
    videoCoverTimestampMs?: number;
    /**
     * Optional for photo carousels. Index of image to use as cover, 0-based (defaults to 0/first image).
     */
    photoCoverIndex?: number;
    /**
     * When true, TikTok may add recommended music (photos only)
     */
    autoAddMusic?: boolean;
    /**
     * Set true to disclose AI-generated content
     */
    videoMadeWithAi?: boolean;
    /**
     * Optional long-form description for photo posts (max 4000 chars). Recommended when content exceeds 90 chars, as photo titles are auto-truncated.
     */
    description?: string;
};

/**
 * Type of commercial content disclosure
 */
export type commercialContentType = 'none' | 'brand_organic' | 'brand_content';

/**
 * Optional override. Defaults based on provided media items.
 */
export type mediaType = 'video' | 'photo';

export type TranscriptResponse = {
    transcript?: string;
    segments?: Array<TranscriptSegment>;
    language?: string;
};

export type TranscriptSegment = {
    text?: string;
    start?: number;
    duration?: number;
};

export type TwitterPlatformData = {
    /**
     * Controls who can reply to the tweet. "following" allows only people you follow, "mentionedUsers" allows only mentioned users, "subscribers" allows only subscribers. Omit for default (everyone can reply). For threads, applies to the first tweet only.
     */
    replySettings?: 'following' | 'mentionedUsers' | 'subscribers';
    /**
     * Sequence of tweets in a thread. First item is the root tweet.
     */
    threadItems?: Array<{
        content?: string;
        mediaItems?: Array<MediaItem>;
    }>;
};

/**
 * Controls who can reply to the tweet. "following" allows only people you follow, "mentionedUsers" allows only mentioned users, "subscribers" allows only subscribers. Omit for default (everyone can reply). For threads, applies to the first tweet only.
 */
export type replySettings = 'following' | 'mentionedUsers' | 'subscribers';

export type UploadedFile = {
    type?: 'image' | 'video' | 'document';
    url?: string;
    filename?: string;
    size?: number;
    mimeType?: string;
};

export type type3 = 'image' | 'video' | 'document';

export type UploadTokenResponse = {
    token?: string;
    uploadUrl?: string;
    expiresAt?: string;
    status?: 'pending' | 'completed' | 'expired';
};

export type status4 = 'pending' | 'completed' | 'expired';

export type UploadTokenStatusResponse = {
    token?: string;
    status?: 'pending' | 'completed' | 'expired';
    files?: Array<UploadedFile>;
    createdAt?: string;
    expiresAt?: string;
    completedAt?: string;
};

export type UsageStats = {
    planName?: string;
    billingPeriod?: 'monthly' | 'yearly';
    signupDate?: string;
    limits?: {
        uploads?: number;
        profiles?: number;
    };
    usage?: {
        uploads?: number;
        profiles?: number;
        lastReset?: string;
    };
};

export type billingPeriod = 'monthly' | 'yearly';

export type User = {
    _id?: string;
    email?: string;
    name?: string;
    role?: string;
    createdAt?: string;
};

export type UserGetResponse = {
    user?: User;
};

export type UsersListResponse = {
    users?: Array<User>;
};

/**
 * Individual webhook configuration for receiving real-time notifications
 */
export type Webhook = {
    /**
     * Unique webhook identifier
     */
    _id?: string;
    /**
     * Webhook name (for identification)
     */
    name?: string;
    /**
     * Webhook endpoint URL
     */
    url?: string;
    /**
     * Secret key for HMAC-SHA256 signature (not returned in responses for security)
     */
    secret?: string;
    /**
     * Events subscribed to
     */
    events?: Array<('post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received' | 'comment.received')>;
    /**
     * Whether webhook delivery is enabled
     */
    isActive?: boolean;
    /**
     * Timestamp of last successful webhook delivery
     */
    lastFiredAt?: string;
    /**
     * Consecutive delivery failures (resets on success, webhook disabled at 10)
     */
    failureCount?: number;
    /**
     * Custom headers included in webhook requests
     */
    customHeaders?: {
        [key: string]: (string);
    };
};

/**
 * Webhook delivery log entry
 */
export type WebhookLog = {
    _id?: string;
    /**
     * ID of the webhook that was triggered
     */
    webhookId?: string;
    /**
     * Name of the webhook that was triggered
     */
    webhookName?: string;
    event?: 'post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received' | 'comment.received' | 'webhook.test';
    url?: string;
    status?: 'success' | 'failed';
    /**
     * HTTP status code from webhook endpoint
     */
    statusCode?: number;
    /**
     * Payload sent to webhook endpoint
     */
    requestPayload?: {
        [key: string]: unknown;
    };
    /**
     * Response body from webhook endpoint (truncated to 10KB)
     */
    responseBody?: string;
    /**
     * Error message if delivery failed
     */
    errorMessage?: string;
    /**
     * Delivery attempt number (max 3 retries)
     */
    attemptNumber?: number;
    /**
     * Response time in milliseconds
     */
    responseTime?: number;
    createdAt?: string;
};

export type event = 'post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received' | 'comment.received' | 'webhook.test';

export type status5 = 'success' | 'failed';

/**
 * Webhook payload for account connected events
 */
export type WebhookPayloadAccountConnected = {
    event?: 'account.connected';
    account?: {
        /**
         * The account's unique identifier (same as used in /v1/accounts/{accountId})
         */
        accountId?: string;
        /**
         * The profile's unique identifier this account belongs to
         */
        profileId?: string;
        platform?: string;
        username?: string;
        displayName?: string;
    };
    timestamp?: string;
};

export type event2 = 'account.connected';

/**
 * Webhook payload for account disconnected events
 */
export type WebhookPayloadAccountDisconnected = {
    event?: 'account.disconnected';
    account?: {
        /**
         * The account's unique identifier (same as used in /v1/accounts/{accountId})
         */
        accountId?: string;
        /**
         * The profile's unique identifier this account belongs to
         */
        profileId?: string;
        platform?: string;
        username?: string;
        displayName?: string;
        /**
         * Whether the disconnection was intentional (user action) or unintentional (token expired/revoked)
         */
        disconnectionType?: 'intentional' | 'unintentional';
        /**
         * Human-readable reason for the disconnection
         */
        reason?: string;
    };
    timestamp?: string;
};

export type event3 = 'account.disconnected';

/**
 * Whether the disconnection was intentional (user action) or unintentional (token expired/revoked)
 */
export type disconnectionType = 'intentional' | 'unintentional';

/**
 * Webhook payload for comment received events (Instagram, Facebook, Twitter/X, YouTube, LinkedIn, Bluesky, Reddit)
 */
export type WebhookPayloadComment = {
    event?: 'comment.received';
    comment?: {
        /**
         * Platform comment ID
         */
        id?: string;
        /**
         * Internal post ID
         */
        postId?: string;
        /**
         * Platform's post ID
         */
        platformPostId?: string;
        platform?: 'instagram' | 'facebook' | 'twitter' | 'youtube' | 'linkedin' | 'bluesky' | 'reddit';
        /**
         * Comment text content
         */
        text?: string;
        author?: {
            /**
             * Author's platform ID
             */
            id?: string;
            username?: string;
            name?: string;
            picture?: (string) | null;
        };
        createdAt?: string;
        /**
         * Whether this is a reply to another comment
         */
        isReply?: boolean;
        /**
         * Parent comment ID if this is a reply
         */
        parentCommentId?: (string) | null;
    };
    post?: {
        /**
         * Internal post ID
         */
        id?: string;
        /**
         * Platform's post ID
         */
        platformPostId?: string;
    };
    account?: {
        /**
         * Social account ID
         */
        id?: string;
        platform?: string;
        username?: string;
    };
    timestamp?: string;
};

export type event4 = 'comment.received';

export type platform2 = 'instagram' | 'facebook' | 'twitter' | 'youtube' | 'linkedin' | 'bluesky' | 'reddit';

/**
 * Webhook payload for message received events (DMs from Instagram, Facebook, Telegram, Bluesky, Reddit)
 */
export type WebhookPayloadMessage = {
    event?: 'message.received';
    message?: {
        /**
         * Internal message ID
         */
        id?: string;
        /**
         * Internal conversation ID
         */
        conversationId?: string;
        platform?: 'instagram' | 'facebook' | 'telegram' | 'bluesky' | 'reddit';
        /**
         * Platform's message ID
         */
        platformMessageId?: string;
        direction?: 'incoming';
        /**
         * Message text content
         */
        text?: (string) | null;
        attachments?: Array<{
            /**
             * Attachment type (image, video, file, sticker, audio)
             */
            type?: string;
            /**
             * Attachment URL (may expire for Meta platforms)
             */
            url?: string;
            /**
             * Additional attachment metadata
             */
            payload?: {
                [key: string]: unknown;
            };
        }>;
        sender?: {
            id?: string;
            name?: string;
            username?: string;
            picture?: string;
            /**
             * Instagram profile data for the sender. Only present for Instagram conversations.
             */
            instagramProfile?: {
                /**
                 * Whether the sender follows your Instagram business account
                 */
                isFollower?: (boolean) | null;
                /**
                 * Whether your Instagram business account follows the sender
                 */
                isFollowing?: (boolean) | null;
                /**
                 * The sender's follower count on Instagram
                 */
                followerCount?: (number) | null;
                /**
                 * Whether the sender is a verified Instagram user
                 */
                isVerified?: (boolean) | null;
            } | null;
        };
        sentAt?: string;
        isRead?: boolean;
    };
    conversation?: {
        id?: string;
        platformConversationId?: string;
        participantId?: string;
        participantName?: string;
        participantUsername?: string;
        participantPicture?: string;
        status?: 'active' | 'archived';
    };
    account?: {
        /**
         * Social account ID
         */
        id?: string;
        platform?: string;
        username?: string;
        displayName?: string;
    };
    /**
     * Interactive message metadata (present when message is a quick reply tap, postback button tap, or inline keyboard callback)
     */
    metadata?: {
        /**
         * Payload from a quick reply tap (Meta platforms)
         */
        quickReplyPayload?: string;
        /**
         * Payload from a postback button tap (Meta platforms)
         */
        postbackPayload?: string;
        /**
         * Title of the tapped postback button (Meta platforms)
         */
        postbackTitle?: string;
        /**
         * Callback data from an inline keyboard button tap (Telegram)
         */
        callbackData?: string;
    } | null;
    timestamp?: string;
};

export type event5 = 'message.received';

export type platform3 = 'instagram' | 'facebook' | 'telegram' | 'bluesky' | 'reddit';

export type direction = 'incoming';

export type status6 = 'active' | 'archived';

/**
 * Webhook payload for post events
 */
export type WebhookPayloadPost = {
    event?: 'post.scheduled' | 'post.published' | 'post.failed' | 'post.partial';
    post?: {
        id?: string;
        content?: string;
        status?: string;
        scheduledFor?: string;
        publishedAt?: string;
        platforms?: Array<{
            platform?: string;
            status?: string;
            publishedUrl?: string;
            error?: string;
        }>;
    };
    timestamp?: string;
};

export type event6 = 'post.scheduled' | 'post.published' | 'post.failed' | 'post.partial';

export type YouTubeDailyViewsResponse = {
    success?: boolean;
    /**
     * The YouTube video ID
     */
    videoId?: string;
    dateRange?: {
        startDate?: string;
        endDate?: string;
    };
    /**
     * Sum of views across all days in the range
     */
    totalViews?: number;
    dailyViews?: Array<{
        date?: string;
        views?: number;
        estimatedMinutesWatched?: number;
        /**
         * Average view duration in seconds
         */
        averageViewDuration?: number;
        subscribersGained?: number;
        subscribersLost?: number;
        likes?: number;
        comments?: number;
        shares?: number;
    }>;
    /**
     * When the data was last synced from YouTube
     */
    lastSyncedAt?: (string) | null;
    scopeStatus?: {
        hasAnalyticsScope?: boolean;
    };
};

/**
 * Videos under 3 min auto-detected as Shorts. Custom thumbnails for regular videos only. Scheduled videos are uploaded immediately with the specified visibility.
 */
export type YouTubePlatformData = {
    /**
     * Video title. Defaults to first line of content or "Untitled Video". Must be ≤ 100 characters.
     */
    title?: string;
    /**
     * Video visibility: public (default, anyone can watch), unlisted (link only), private (invite only)
     */
    visibility?: 'public' | 'private' | 'unlisted';
    /**
     * COPPA compliance flag. Set true for child-directed content (restricts comments, notifications, ad targeting). Defaults to false. YouTube may block views if not explicitly set.
     */
    madeForKids?: boolean;
    /**
     * Optional first comment to post immediately after video upload. Up to 10,000 characters (YouTube's comment limit).
     */
    firstComment?: string;
    /**
     * AI-generated content disclosure. Set true if the video contains synthetic content that could be mistaken for real. YouTube may add a label.
     */
    containsSyntheticMedia?: boolean;
    /**
     * YouTube video category ID. Defaults to 22 (People & Blogs). Common: 1 (Film), 2 (Autos), 10 (Music), 15 (Pets), 17 (Sports), 20 (Gaming), 23 (Comedy), 24 (Entertainment), 25 (News), 26 (Howto), 27 (Education), 28 (Science & Tech).
     */
    categoryId?: string;
};

export type YouTubeScopeMissingResponse = {
    success?: boolean;
    error?: string;
    code?: string;
    scopeStatus?: {
        hasAnalyticsScope?: boolean;
        requiresReauthorization?: boolean;
        /**
         * URL to redirect user for reauthorization
         */
        reauthorizeUrl?: string;
    };
};

export type DownloadYouTubeVideoData = {
    query: {
        /**
         * Action to perform: 'download' returns download URL, 'formats' lists available formats
         */
        action?: 'download' | 'formats';
        /**
         * Desired format (when action=download)
         */
        format?: 'video' | 'audio';
        /**
         * Specific format ID from formats list
         */
        formatId?: string;
        /**
         * Desired quality (when action=download)
         */
        quality?: 'hd' | 'sd';
        /**
         * YouTube video URL or video ID
         */
        url: string;
    };
};

export type DownloadYouTubeVideoResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
    formats?: Array<{
        id?: string;
        label?: string;
        ext?: string;
        type?: string;
        height?: number;
        width?: number;
    }>;
});

export type DownloadYouTubeVideoError = ({
    error?: string;
} | unknown);

export type GetYouTubeTranscriptData = {
    query: {
        /**
         * Language code for transcript
         */
        lang?: string;
        /**
         * YouTube video URL or video ID
         */
        url: string;
    };
};

export type GetYouTubeTranscriptResponse = ({
    success?: boolean;
    videoId?: string;
    language?: string;
    fullText?: string;
    segments?: Array<{
        text?: string;
        start?: number;
        duration?: number;
    }>;
});

export type GetYouTubeTranscriptError = (unknown);

export type DownloadInstagramMediaData = {
    query: {
        /**
         * Instagram reel or post URL
         */
        url: string;
    };
};

export type DownloadInstagramMediaResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
});

export type DownloadInstagramMediaError = unknown;

export type CheckInstagramHashtagsData = {
    body: {
        hashtags: Array<(string)>;
    };
};

export type CheckInstagramHashtagsResponse = ({
    success?: boolean;
    results?: Array<{
        hashtag?: string;
        status?: 'banned' | 'restricted' | 'safe' | 'unknown';
        reason?: string;
        confidence?: number;
    }>;
    summary?: {
        banned?: number;
        restricted?: number;
        safe?: number;
    };
});

export type CheckInstagramHashtagsError = unknown;

export type DownloadTikTokVideoData = {
    query: {
        /**
         * 'formats' to list available formats
         */
        action?: 'download' | 'formats';
        /**
         * Specific format ID (0 = no watermark, etc.)
         */
        formatId?: string;
        /**
         * TikTok video URL or ID
         */
        url: string;
    };
};

export type DownloadTikTokVideoResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
    formats?: Array<{
        id?: string;
        label?: string;
        ext?: string;
    }>;
});

export type DownloadTikTokVideoError = unknown;

export type DownloadTwitterMediaData = {
    query: {
        action?: 'download' | 'formats';
        formatId?: string;
        /**
         * Twitter/X post URL
         */
        url: string;
    };
};

export type DownloadTwitterMediaResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
});

export type DownloadTwitterMediaError = unknown;

export type DownloadFacebookVideoData = {
    query: {
        /**
         * Facebook video or reel URL
         */
        url: string;
    };
};

export type DownloadFacebookVideoResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
    thumbnail?: string;
});

export type DownloadFacebookVideoError = unknown;

export type DownloadLinkedInVideoData = {
    query: {
        /**
         * LinkedIn post URL
         */
        url: string;
    };
};

export type DownloadLinkedInVideoResponse = ({
    success?: boolean;
    title?: string;
    downloadUrl?: string;
});

export type DownloadLinkedInVideoError = unknown;

export type DownloadBlueskyMediaData = {
    query: {
        /**
         * Bluesky post URL
         */
        url: string;
    };
};

export type DownloadBlueskyMediaResponse = ({
    success?: boolean;
    title?: string;
    text?: string;
    downloadUrl?: string;
    thumbnail?: string;
});

export type DownloadBlueskyMediaError = unknown;

export type GetAnalyticsData = {
    query?: {
        /**
         * Inclusive lower bound
         */
        fromDate?: string;
        /**
         * Page size (default 50)
         */
        limit?: number;
        /**
         * Sort order
         */
        order?: 'asc' | 'desc';
        /**
         * Page number (default 1)
         */
        page?: number;
        /**
         * Filter by platform (default "all")
         */
        platform?: string;
        /**
         * Returns analytics for a single post. Accepts both Late Post IDs and External Post IDs. Late IDs are auto-resolved to External Post analytics.
         */
        postId?: string;
        /**
         * Filter by profile ID (default "all")
         */
        profileId?: string;
        /**
         * Sort by date or engagement
         */
        sortBy?: 'date' | 'engagement';
        /**
         * Filter by post source: late (posted via Late API), external (synced from platform), all (default)
         */
        source?: 'all' | 'late' | 'external';
        /**
         * Inclusive upper bound
         */
        toDate?: string;
    };
};

export type GetAnalyticsResponse = ((AnalyticsSinglePostResponse | AnalyticsListResponse));

export type GetAnalyticsError = ({
    error?: string;
} | {
    error?: string;
    code?: string;
} | ErrorResponse);

export type GetYouTubeDailyViewsData = {
    query: {
        /**
         * The Late account ID for the YouTube account
         */
        accountId: string;
        /**
         * End date (YYYY-MM-DD). Defaults to 3 days ago (YouTube data latency).
         */
        endDate?: string;
        /**
         * Start date (YYYY-MM-DD). Defaults to 30 days ago.
         */
        startDate?: string;
        /**
         * The YouTube video ID (e.g., "dQw4w9WgXcQ")
         */
        videoId: string;
    };
};

export type GetYouTubeDailyViewsResponse = (YouTubeDailyViewsResponse);

export type GetYouTubeDailyViewsError = ({
    error?: string;
} | {
    error?: string;
    code?: string;
} | YouTubeScopeMissingResponse | {
    success?: boolean;
    error?: string;
});

export type ListAccountGroupsResponse = ({
    groups?: Array<{
        _id?: string;
        name?: string;
        accountIds?: Array<(string)>;
    }>;
});

export type ListAccountGroupsError = ({
    error?: string;
});

export type CreateAccountGroupData = {
    body: {
        name: string;
        accountIds: Array<(string)>;
    };
};

export type CreateAccountGroupResponse = ({
    message?: string;
    group?: {
        _id?: string;
        name?: string;
        accountIds?: Array<(string)>;
    };
});

export type CreateAccountGroupError = (unknown | {
    error?: string;
});

export type UpdateAccountGroupData = {
    body: {
        name?: string;
        accountIds?: Array<(string)>;
    };
    path: {
        groupId: string;
    };
};

export type UpdateAccountGroupResponse = ({
    message?: string;
    group?: {
        [key: string]: unknown;
    };
});

export type UpdateAccountGroupError = ({
    error?: string;
} | unknown);

export type DeleteAccountGroupData = {
    path: {
        groupId: string;
    };
};

export type DeleteAccountGroupResponse = ({
    message?: string;
});

export type DeleteAccountGroupError = ({
    error?: string;
});

export type GetMediaPresignedUrlData = {
    body: {
        /**
         * Name of the file to upload
         */
        filename: string;
        /**
         * MIME type of the file
         */
        contentType: 'image/jpeg' | 'image/jpg' | 'image/png' | 'image/webp' | 'image/gif' | 'video/mp4' | 'video/mpeg' | 'video/quicktime' | 'video/avi' | 'video/x-msvideo' | 'video/webm' | 'video/x-m4v' | 'application/pdf';
        /**
         * Optional file size in bytes for pre-validation (max 5GB)
         */
        size?: number;
    };
};

export type GetMediaPresignedUrlResponse = ({
    /**
     * Presigned URL to PUT your file to (expires in 1 hour)
     */
    uploadUrl?: string;
    /**
     * Public URL where the file will be accessible after upload
     */
    publicUrl?: string;
    /**
     * Storage key/path of the file
     */
    key?: string;
    /**
     * Detected file type based on content type
     */
    type?: 'image' | 'video' | 'document';
});

export type GetMediaPresignedUrlError = ({
    error?: string;
});

export type SearchRedditData = {
    query: {
        accountId: string;
        after?: string;
        limit?: number;
        q: string;
        restrict_sr?: '0' | '1';
        sort?: 'relevance' | 'hot' | 'top' | 'new' | 'comments';
        subreddit?: string;
    };
};

export type SearchRedditResponse = ({
    posts?: Array<{
        id?: string;
        title?: string;
        selftext?: string;
        author?: string;
        subreddit?: string;
        score?: number;
        num_comments?: number;
        created_utc?: number;
        permalink?: string;
    }>;
    after?: string;
});

export type SearchRedditError = (unknown | {
    error?: string;
});

export type GetRedditFeedData = {
    query: {
        accountId: string;
        after?: string;
        limit?: number;
        sort?: 'hot' | 'new' | 'top' | 'rising';
        subreddit?: string;
        t?: 'hour' | 'day' | 'week' | 'month' | 'year' | 'all';
    };
};

export type GetRedditFeedResponse = ({
    posts?: Array<{
        [key: string]: unknown;
    }>;
    after?: string;
});

export type GetRedditFeedError = (unknown | {
    error?: string;
});

export type GetUsageStatsResponse = (UsageStats);

export type GetUsageStatsError = ({
    error?: string;
});

export type ListPostsData = {
    query?: {
        createdBy?: string;
        dateFrom?: string;
        dateTo?: string;
        includeHidden?: boolean;
        /**
         * Page size
         */
        limit?: number;
        /**
         * Page number (1-based)
         */
        page?: number;
        platform?: string;
        profileId?: string;
        status?: 'draft' | 'scheduled' | 'published' | 'failed';
    };
};

export type ListPostsResponse = (PostsListResponse);

export type ListPostsError = ({
    error?: string;
});

export type CreatePostData = {
    body: {
        title?: string;
        /**
         * Post caption/text. Optional when media is attached or all platforms have customContent. Required for text-only posts.
         */
        content?: string;
        mediaItems?: Array<{
            type?: 'image' | 'video' | 'gif' | 'document';
            url?: string;
        }>;
        platforms?: Array<{
            platform?: string;
            accountId?: string;
            /**
             * Platform-specific text override. When set, this content is used instead of the top-level post content for this platform. Useful for tailoring captions per platform (e.g. keeping tweets under 280 characters).
             */
            customContent?: string;
            customMedia?: Array<{
                type?: 'image' | 'video' | 'gif' | 'document';
                url?: string;
            }>;
            /**
             * Optional per-platform scheduled time override. When omitted, the top-level scheduledFor is used.
             */
            scheduledFor?: string;
            platformSpecificData?: (TwitterPlatformData | ThreadsPlatformData | FacebookPlatformData | InstagramPlatformData | LinkedInPlatformData | PinterestPlatformData | YouTubePlatformData | GoogleBusinessPlatformData | TikTokPlatformData | TelegramPlatformData | SnapchatPlatformData | RedditPlatformData | BlueskyPlatformData);
        }>;
        scheduledFor?: string;
        publishNow?: boolean;
        isDraft?: boolean;
        timezone?: string;
        /**
         * Tags/keywords. YouTube constraints: each tag max 100 chars, combined max 500 chars, duplicates auto-removed.
         */
        tags?: Array<(string)>;
        hashtags?: Array<(string)>;
        mentions?: Array<(string)>;
        crosspostingEnabled?: boolean;
        metadata?: {
            [key: string]: unknown;
        };
        /**
         * Root-level TikTok settings applied to all TikTok platforms. Merged into each platform's platformSpecificData, with platform-specific settings taking precedence.
         */
        tiktokSettings?: TikTokPlatformData;
        /**
         * Profile ID to schedule via queue. When provided without scheduledFor, the post is auto-assigned to the next available slot. Do not call /v1/queue/next-slot and use that time in scheduledFor, as that bypasses queue locking.
         */
        queuedFromProfile?: string;
        /**
         * Specific queue ID to use when scheduling via queue.
         * Only used when queuedFromProfile is also provided.
         * If omitted, uses the profile's default queue.
         *
         */
        queueId?: string;
    };
};

export type CreatePostResponse = (PostCreateResponse);

export type CreatePostError = ({
    error?: string;
} | {
    error?: string;
    details?: {
        accountId?: string;
        platform?: string;
        existingPostId?: string;
    };
} | {
    error?: string;
    /**
     * Additional context about the rate limit
     */
    details?: {
        [key: string]: unknown;
    };
});

export type GetPostData = {
    path: {
        postId: string;
    };
};

export type GetPostResponse = (PostGetResponse);

export type GetPostError = ({
    error?: string;
} | unknown);

export type UpdatePostData = {
    body: {
        content?: string;
        scheduledFor?: string;
        /**
         * Root-level TikTok settings applied to all TikTok platforms. Merged into each platform's platformSpecificData, with platform-specific settings taking precedence.
         */
        tiktokSettings?: TikTokPlatformData;
        [key: string]: unknown | string | TikTokPlatformData;
    };
    path: {
        postId: string;
    };
};

export type UpdatePostResponse = (PostUpdateResponse | unknown);

export type UpdatePostError = (unknown | {
    error?: string;
});

export type DeletePostData = {
    path: {
        postId: string;
    };
};

export type DeletePostResponse = (PostDeleteResponse);

export type DeletePostError = (unknown | {
    error?: string;
});

export type BulkUploadPostsData = {
    body: {
        file?: (Blob | File);
    };
    query?: {
        dryRun?: boolean;
    };
};

export type BulkUploadPostsResponse = ({
    success?: boolean;
    totalRows?: number;
    created?: number;
    failed?: number;
    errors?: Array<{
        row?: number;
        error?: string;
    }>;
    posts?: Array<Post>;
} | unknown);

export type BulkUploadPostsError = (unknown | {
    error?: string;
} | {
    error?: string;
    details?: {
        [key: string]: unknown;
    };
});

export type RetryPostData = {
    path: {
        postId: string;
    };
};

export type RetryPostResponse = (PostRetryResponse | unknown);

export type RetryPostError = (unknown | {
    error?: string;
} | {
    error?: string;
    details?: {
        [key: string]: unknown;
    };
});

export type UnpublishPostData = {
    body: {
        /**
         * The platform to delete the post from
         */
        platform: 'threads' | 'facebook' | 'twitter' | 'linkedin' | 'youtube' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram';
    };
    path: {
        postId: string;
    };
};

export type UnpublishPostResponse = ({
    success?: boolean;
    message?: string;
});

export type UnpublishPostError = (unknown | {
    error?: string;
});

export type ListUsersResponse = ({
    currentUserId?: string;
    users?: Array<{
        _id?: string;
        name?: string;
        email?: string;
        role?: string;
        isRoot?: boolean;
        profileAccess?: Array<(string)>;
        createdAt?: string;
    }>;
});

export type ListUsersError = ({
    error?: string;
});

export type GetUserData = {
    path: {
        userId: string;
    };
};

export type GetUserResponse = ({
    user?: {
        _id?: string;
        name?: string;
        email?: string;
        role?: string;
        isRoot?: boolean;
        profileAccess?: Array<(string)>;
    };
});

export type GetUserError = ({
    error?: string;
} | unknown);

export type ListProfilesData = {
    query?: {
        /**
         * When true, includes over-limit profiles (marked with isOverLimit: true).
         */
        includeOverLimit?: boolean;
    };
};

export type ListProfilesResponse = (ProfilesListResponse);

export type ListProfilesError = ({
    error?: string;
});

export type CreateProfileData = {
    body: {
        name: string;
        description?: string;
        color?: string;
    };
};

export type CreateProfileResponse = (ProfileCreateResponse);

export type CreateProfileError = (unknown | {
    error?: string;
});

export type GetProfileData = {
    path: {
        profileId: string;
    };
};

export type GetProfileResponse = ({
    profile?: Profile;
});

export type GetProfileError = ({
    error?: string;
});

export type UpdateProfileData = {
    body: {
        name?: string;
        description?: string;
        color?: string;
        isDefault?: boolean;
    };
    path: {
        profileId: string;
    };
};

export type UpdateProfileResponse = ({
    message?: string;
    profile?: Profile;
});

export type UpdateProfileError = ({
    error?: string;
});

export type DeleteProfileData = {
    path: {
        profileId: string;
    };
};

export type DeleteProfileResponse = ({
    message?: string;
});

export type DeleteProfileError = (unknown | {
    error?: string;
});

export type ListAccountsData = {
    query?: {
        /**
         * When true, includes accounts from over-limit profiles.
         */
        includeOverLimit?: boolean;
        /**
         * Filter accounts by profile ID
         */
        profileId?: string;
    };
};

export type ListAccountsResponse = ({
    accounts?: Array<SocialAccount>;
    /**
     * Whether user has analytics add-on access
     */
    hasAnalyticsAccess?: boolean;
});

export type ListAccountsError = ({
    error?: string;
});

export type GetFollowerStatsData = {
    query?: {
        /**
         * Comma-separated list of account IDs (optional, defaults to all user's accounts)
         */
        accountIds?: string;
        /**
         * Start date in YYYY-MM-DD format (defaults to 30 days ago)
         */
        fromDate?: string;
        /**
         * Data aggregation level
         */
        granularity?: 'daily' | 'weekly' | 'monthly';
        /**
         * Filter by profile ID
         */
        profileId?: string;
        /**
         * End date in YYYY-MM-DD format (defaults to today)
         */
        toDate?: string;
    };
};

export type GetFollowerStatsResponse = ({
    accounts?: Array<AccountWithFollowerStats>;
    stats?: {
        [key: string]: Array<{
            date?: string;
            followers?: number;
        }>;
    };
    dateRange?: {
        from?: string;
        to?: string;
    };
    granularity?: string;
});

export type GetFollowerStatsError = ({
    error?: string;
} | {
    error?: string;
    message?: string;
    requiresAddon?: boolean;
});

export type UpdateAccountData = {
    body: {
        username?: string;
        displayName?: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdateAccountResponse = ({
    message?: string;
    username?: string;
    displayName?: string;
});

export type UpdateAccountError = (unknown | {
    error?: string;
});

export type DeleteAccountData = {
    path: {
        accountId: string;
    };
};

export type DeleteAccountResponse = ({
    message?: string;
});

export type DeleteAccountError = ({
    error?: string;
});

export type GetAllAccountsHealthData = {
    query?: {
        /**
         * Filter by platform
         */
        platform?: 'facebook' | 'instagram' | 'linkedin' | 'twitter' | 'tiktok' | 'youtube' | 'threads' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat';
        /**
         * Filter by profile ID
         */
        profileId?: string;
        /**
         * Filter by health status
         */
        status?: 'healthy' | 'warning' | 'error';
    };
};

export type GetAllAccountsHealthResponse = ({
    summary?: {
        /**
         * Total number of accounts
         */
        total?: number;
        /**
         * Number of healthy accounts
         */
        healthy?: number;
        /**
         * Number of accounts with warnings
         */
        warning?: number;
        /**
         * Number of accounts with errors
         */
        error?: number;
        /**
         * Number of accounts needing reconnection
         */
        needsReconnect?: number;
    };
    accounts?: Array<{
        accountId?: string;
        platform?: string;
        username?: string;
        displayName?: string;
        profileId?: string;
        status?: 'healthy' | 'warning' | 'error';
        canPost?: boolean;
        canFetchAnalytics?: boolean;
        tokenValid?: boolean;
        tokenExpiresAt?: string;
        needsReconnect?: boolean;
        issues?: Array<(string)>;
    }>;
});

export type GetAllAccountsHealthError = ({
    error?: string;
});

export type GetAccountHealthData = {
    path: {
        /**
         * The account ID to check
         */
        accountId: string;
    };
};

export type GetAccountHealthResponse = ({
    accountId?: string;
    platform?: string;
    username?: string;
    displayName?: string;
    /**
     * Overall health status
     */
    status?: 'healthy' | 'warning' | 'error';
    tokenStatus?: {
        /**
         * Whether the token is valid
         */
        valid?: boolean;
        expiresAt?: string;
        /**
         * Human-readable time until expiry
         */
        expiresIn?: string;
        /**
         * Whether token expires within 24 hours
         */
        needsRefresh?: boolean;
    };
    permissions?: {
        posting?: Array<{
            scope?: string;
            granted?: boolean;
            required?: boolean;
        }>;
        analytics?: Array<{
            scope?: string;
            granted?: boolean;
            required?: boolean;
        }>;
        optional?: Array<{
            scope?: string;
            granted?: boolean;
            required?: boolean;
        }>;
        canPost?: boolean;
        canFetchAnalytics?: boolean;
        missingRequired?: Array<(string)>;
    };
    /**
     * List of issues found
     */
    issues?: Array<(string)>;
    /**
     * Actionable recommendations to fix issues
     */
    recommendations?: Array<(string)>;
});

export type GetAccountHealthError = ({
    error?: string;
});

export type ListApiKeysResponse = ({
    apiKeys?: Array<ApiKey>;
});

export type ListApiKeysError = ({
    error?: string;
});

export type CreateApiKeyData = {
    body: {
        name: string;
        /**
         * Days until expiry
         */
        expiresIn?: number;
        /**
         * 'full' grants access to all profiles (default), 'profiles' restricts to specific profiles
         */
        scope?: 'full' | 'profiles';
        /**
         * Profile IDs this key can access. Required when scope is 'profiles'.
         */
        profileIds?: Array<(string)>;
        /**
         * 'read-write' allows all operations (default), 'read' restricts to GET requests only
         */
        permission?: 'read-write' | 'read';
    };
};

export type CreateApiKeyResponse = ({
    message?: string;
    apiKey?: ApiKey;
});

export type CreateApiKeyError = (unknown | {
    error?: string;
});

export type DeleteApiKeyData = {
    path: {
        keyId: string;
    };
};

export type DeleteApiKeyResponse = ({
    message?: string;
});

export type DeleteApiKeyError = ({
    error?: string;
});

export type CreateInviteTokenData = {
    body: {
        /**
         * 'all' grants access to all profiles, 'profiles' restricts to specific profiles
         */
        scope: 'all' | 'profiles';
        /**
         * Required if scope is 'profiles'. Array of profile IDs to grant access to.
         */
        profileIds?: Array<(string)>;
    };
};

export type CreateInviteTokenResponse = ({
    token?: string;
    scope?: string;
    invitedProfileIds?: Array<(string)>;
    expiresAt?: string;
    inviteUrl?: string;
});

export type CreateInviteTokenError = (unknown | {
    error?: string;
});

export type GetConnectUrlData = {
    path: {
        /**
         * Social media platform to connect
         */
        platform: 'facebook' | 'instagram' | 'linkedin' | 'twitter' | 'tiktok' | 'youtube' | 'threads' | 'reddit' | 'pinterest' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat';
    };
    query: {
        /**
         * Your Late profile ID (get from /v1/profiles)
         */
        profileId: string;
        /**
         * Your custom redirect URL after connection completes. Standard mode appends ?connected={platform}&profileId=X&username=Y. Headless mode appends OAuth data params.
         */
        redirect_url?: string;
    };
};

export type GetConnectUrlResponse = ({
    /**
     * URL to redirect your user to for OAuth authorization
     */
    authUrl?: string;
    /**
     * State parameter for security (handled automatically)
     */
    state?: string;
});

export type GetConnectUrlError = (unknown | {
    error?: string;
});

export type HandleOAuthCallbackData = {
    body: {
        code: string;
        state: string;
        profileId: string;
    };
    path: {
        platform: string;
    };
};

export type HandleOAuthCallbackResponse = (unknown);

export type HandleOAuthCallbackError = (unknown | {
    error?: string;
});

export type ListFacebookPagesData = {
    query: {
        /**
         * Profile ID from your connection flow
         */
        profileId: string;
        /**
         * Temporary Facebook access token from the OAuth callback redirect
         */
        tempToken: string;
    };
};

export type ListFacebookPagesResponse = ({
    pages?: Array<{
        /**
         * Facebook Page ID
         */
        id?: string;
        /**
         * Page name
         */
        name?: string;
        /**
         * Page username/handle (may be null)
         */
        username?: string;
        /**
         * Page-specific access token
         */
        access_token?: string;
        /**
         * Page category
         */
        category?: string;
        /**
         * User permissions for this page
         */
        tasks?: Array<(string)>;
    }>;
});

export type ListFacebookPagesError = (unknown | {
    error?: string;
});

export type SelectFacebookPageData = {
    body: {
        /**
         * Profile ID from your connection flow
         */
        profileId: string;
        /**
         * The Facebook Page ID selected by the user
         */
        pageId: string;
        /**
         * Temporary Facebook access token from OAuth
         */
        tempToken: string;
        /**
         * Decoded user profile object from the OAuth callback
         */
        userProfile?: {
            id?: string;
            name?: string;
            profilePicture?: string;
        };
        /**
         * Optional custom redirect URL to return to after selection
         */
        redirect_url?: string;
    };
};

export type SelectFacebookPageResponse = ({
    message?: string;
    /**
     * Redirect URL if custom redirect_url was provided
     */
    redirect_url?: string;
    account?: {
        /**
         * ID of the created SocialAccount
         */
        accountId?: string;
        platform?: 'facebook';
        username?: string;
        displayName?: string;
        profilePicture?: string;
        isActive?: boolean;
        selectedPageName?: string;
    };
});

export type SelectFacebookPageError = (unknown | {
    error?: string;
});

export type ListGoogleBusinessLocationsData = {
    query: {
        /**
         * Profile ID from your connection flow
         */
        profileId: string;
        /**
         * Temporary Google access token from the OAuth callback redirect
         */
        tempToken: string;
    };
};

export type ListGoogleBusinessLocationsResponse = ({
    locations?: Array<{
        /**
         * Location ID
         */
        id?: string;
        /**
         * Business name
         */
        name?: string;
        /**
         * Google Business Account ID
         */
        accountId?: string;
        /**
         * Account name
         */
        accountName?: string;
        /**
         * Business address
         */
        address?: string;
        /**
         * Business category
         */
        category?: string;
    }>;
});

export type ListGoogleBusinessLocationsError = (unknown | {
    error?: string;
});

export type SelectGoogleBusinessLocationData = {
    body: {
        /**
         * Profile ID from your connection flow
         */
        profileId: string;
        /**
         * The Google Business location ID selected by the user
         */
        locationId: string;
        /**
         * Temporary Google access token from OAuth
         */
        tempToken: string;
        /**
         * Decoded user profile from the OAuth callback. Contains the refresh token. Always include this field.
         */
        userProfile?: {
            id?: string;
            name?: string;
            /**
             * Google refresh token for long-lived access
             */
            refreshToken?: string;
            /**
             * Token expiration time in seconds
             */
            tokenExpiresIn?: number;
            /**
             * Granted OAuth scopes
             */
            scope?: string;
        };
        /**
         * Optional custom redirect URL to return to after selection
         */
        redirect_url?: string;
    };
};

export type SelectGoogleBusinessLocationResponse = ({
    message?: string;
    /**
     * Redirect URL if custom redirect_url was provided
     */
    redirect_url?: string;
    account?: {
        /**
         * ID of the created SocialAccount
         */
        accountId?: string;
        platform?: 'googlebusiness';
        username?: string;
        displayName?: string;
        isActive?: boolean;
        selectedLocationName?: string;
        selectedLocationId?: string;
    };
});

export type SelectGoogleBusinessLocationError = (unknown | {
    error?: string;
});

export type GetGoogleBusinessReviewsData = {
    path: {
        /**
         * The Late account ID (from /v1/accounts)
         */
        accountId: string;
    };
    query?: {
        /**
         * Number of reviews to fetch per page (max 50)
         */
        pageSize?: number;
        /**
         * Pagination token from previous response
         */
        pageToken?: string;
    };
};

export type GetGoogleBusinessReviewsResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    reviews?: Array<{
        /**
         * Review ID
         */
        id?: string;
        /**
         * Full resource name
         */
        name?: string;
        reviewer?: {
            displayName?: string;
            profilePhotoUrl?: (string) | null;
            isAnonymous?: boolean;
        };
        /**
         * Numeric star rating
         */
        rating?: number;
        /**
         * Google's string rating
         */
        starRating?: 'ONE' | 'TWO' | 'THREE' | 'FOUR' | 'FIVE';
        /**
         * Review text
         */
        comment?: string;
        createTime?: string;
        updateTime?: string;
        reviewReply?: {
            /**
             * Business owner reply
             */
            comment?: string;
            updateTime?: string;
        } | null;
    }>;
    /**
     * Overall average rating
     */
    averageRating?: number;
    /**
     * Total number of reviews
     */
    totalReviewCount?: number;
    /**
     * Token for next page
     */
    nextPageToken?: (string) | null;
});

export type GetGoogleBusinessReviewsError = (ErrorResponse | {
    error?: string;
});

export type GetGoogleBusinessFoodMenusData = {
    path: {
        /**
         * The Late account ID (from /v1/accounts)
         */
        accountId: string;
    };
};

export type GetGoogleBusinessFoodMenusResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    /**
     * Resource name of the food menus
     */
    name?: string;
    menus?: Array<FoodMenu>;
});

export type GetGoogleBusinessFoodMenusError = (ErrorResponse | {
    error?: string;
});

export type UpdateGoogleBusinessFoodMenusData = {
    body: {
        /**
         * Array of food menus to set
         */
        menus: Array<FoodMenu>;
        /**
         * Field mask for partial updates (e.g. "menus")
         */
        updateMask?: string;
    };
    path: {
        /**
         * The Late account ID (from /v1/accounts)
         */
        accountId: string;
    };
};

export type UpdateGoogleBusinessFoodMenusResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    name?: string;
    menus?: Array<FoodMenu>;
});

export type UpdateGoogleBusinessFoodMenusError = (ErrorResponse | {
    error?: string;
});

export type GetGoogleBusinessLocationDetailsData = {
    path: {
        /**
         * The Late account ID (from /v1/accounts)
         */
        accountId: string;
    };
    query?: {
        /**
         * Comma-separated fields to return. Available: name, title, phoneNumbers, categories, storefrontAddress, websiteUri, regularHours, specialHours, serviceArea, profile, openInfo, metadata, moreHours.
         */
        readMask?: string;
    };
};

export type GetGoogleBusinessLocationDetailsResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    /**
     * Business name
     */
    title?: string;
    regularHours?: {
        periods?: Array<{
            openDay?: 'MONDAY' | 'TUESDAY' | 'WEDNESDAY' | 'THURSDAY' | 'FRIDAY' | 'SATURDAY' | 'SUNDAY';
            /**
             * Opening time in HH:MM format
             */
            openTime?: string;
            closeDay?: string;
            closeTime?: string;
        }>;
    };
    specialHours?: {
        specialHourPeriods?: Array<{
            startDate?: {
                year?: number;
                month?: number;
                day?: number;
            };
            endDate?: {
                year?: number;
                month?: number;
                day?: number;
            };
            openTime?: string;
            closeTime?: string;
            closed?: boolean;
        }>;
    };
    profile?: {
        /**
         * Business description
         */
        description?: string;
    };
    websiteUri?: string;
    phoneNumbers?: {
        primaryPhone?: string;
        additionalPhones?: Array<(string)>;
    };
});

export type GetGoogleBusinessLocationDetailsError = (ErrorResponse | {
    error?: string;
});

export type UpdateGoogleBusinessLocationDetailsData = {
    body: {
        /**
         * Required. Comma-separated fields to update (e.g. 'regularHours', 'specialHours', 'profile.description')
         */
        updateMask: string;
        regularHours?: {
            periods?: Array<{
                openDay?: string;
                openTime?: string;
                closeDay?: string;
                closeTime?: string;
            }>;
        };
        specialHours?: {
            specialHourPeriods?: Array<{
                startDate?: {
                    year?: number;
                    month?: number;
                    day?: number;
                };
                endDate?: {
                    year?: number;
                    month?: number;
                    day?: number;
                };
                openTime?: string;
                closeTime?: string;
                closed?: boolean;
            }>;
        };
        profile?: {
            description?: string;
        };
        websiteUri?: string;
        phoneNumbers?: {
            primaryPhone?: string;
            additionalPhones?: Array<(string)>;
        };
    };
    path: {
        /**
         * The Late account ID (from /v1/accounts)
         */
        accountId: string;
    };
};

export type UpdateGoogleBusinessLocationDetailsResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
});

export type UpdateGoogleBusinessLocationDetailsError = (ErrorResponse | {
    error?: string;
});

export type ListGoogleBusinessMediaData = {
    path: {
        accountId: string;
    };
    query?: {
        /**
         * Number of items to return (max 100)
         */
        pageSize?: number;
        /**
         * Pagination token from previous response
         */
        pageToken?: string;
    };
};

export type ListGoogleBusinessMediaResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    mediaItems?: Array<{
        /**
         * Resource name
         */
        name?: string;
        mediaFormat?: 'PHOTO' | 'VIDEO';
        sourceUrl?: string;
        /**
         * Google-hosted URL
         */
        googleUrl?: string;
        thumbnailUrl?: string;
        description?: string;
        createTime?: string;
        locationAssociation?: {
            category?: string;
        };
    }>;
    nextPageToken?: string;
    totalMediaItemsCount?: number;
});

export type ListGoogleBusinessMediaError = (ErrorResponse);

export type CreateGoogleBusinessMediaData = {
    body: {
        /**
         * Publicly accessible image URL
         */
        sourceUrl: string;
        mediaFormat?: 'PHOTO' | 'VIDEO';
        /**
         * Photo description
         */
        description?: string;
        /**
         * Where the photo appears on the listing
         */
        category?: 'COVER' | 'PROFILE' | 'LOGO' | 'EXTERIOR' | 'INTERIOR' | 'FOOD_AND_DRINK' | 'MENU' | 'PRODUCT' | 'TEAMS' | 'ADDITIONAL';
    };
    path: {
        accountId: string;
    };
};

export type CreateGoogleBusinessMediaResponse = ({
    success?: boolean;
    name?: string;
    mediaFormat?: string;
    googleUrl?: string;
});

export type CreateGoogleBusinessMediaError = (ErrorResponse);

export type DeleteGoogleBusinessMediaData = {
    path: {
        accountId: string;
    };
    query: {
        /**
         * The media item ID to delete
         */
        mediaId: string;
    };
};

export type DeleteGoogleBusinessMediaResponse = ({
    success?: boolean;
    deleted?: boolean;
    mediaId?: string;
});

export type DeleteGoogleBusinessMediaError = (ErrorResponse);

export type GetGoogleBusinessAttributesData = {
    path: {
        accountId: string;
    };
};

export type GetGoogleBusinessAttributesResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    attributes?: Array<{
        /**
         * Attribute identifier (e.g. has_delivery)
         */
        name?: string;
        /**
         * Value type (BOOL, ENUM, URL, REPEATED_ENUM)
         */
        valueType?: string;
        values?: Array<unknown>;
        repeatedEnumValue?: {
            setValues?: Array<(string)>;
            unsetValues?: Array<(string)>;
        };
    }>;
});

export type GetGoogleBusinessAttributesError = (ErrorResponse);

export type UpdateGoogleBusinessAttributesData = {
    body: {
        attributes: Array<{
            name?: string;
            values?: Array<unknown>;
            repeatedEnumValue?: {
                setValues?: Array<(string)>;
                unsetValues?: Array<(string)>;
            };
        }>;
        /**
         * Comma-separated attribute names to update (e.g. 'has_delivery,has_takeout')
         */
        attributeMask: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdateGoogleBusinessAttributesResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    attributes?: Array<{
        [key: string]: unknown;
    }>;
});

export type UpdateGoogleBusinessAttributesError = (ErrorResponse);

export type ListGoogleBusinessPlaceActionsData = {
    path: {
        accountId: string;
    };
    query?: {
        pageSize?: number;
        pageToken?: string;
    };
};

export type ListGoogleBusinessPlaceActionsResponse = ({
    success?: boolean;
    accountId?: string;
    locationId?: string;
    placeActionLinks?: Array<{
        /**
         * Resource name
         */
        name?: string;
        /**
         * Action URL
         */
        uri?: string;
        placeActionType?: string;
        createTime?: string;
        updateTime?: string;
    }>;
    nextPageToken?: string;
});

export type ListGoogleBusinessPlaceActionsError = (ErrorResponse);

export type CreateGoogleBusinessPlaceActionData = {
    body: {
        /**
         * The action URL
         */
        uri: string;
        /**
         * Type of action
         */
        placeActionType: 'APPOINTMENT' | 'ONLINE_APPOINTMENT' | 'DINING_RESERVATION' | 'FOOD_ORDERING' | 'FOOD_DELIVERY' | 'FOOD_TAKEOUT' | 'SHOP_ONLINE';
    };
    path: {
        accountId: string;
    };
};

export type CreateGoogleBusinessPlaceActionResponse = ({
    success?: boolean;
    /**
     * Resource name of the created link
     */
    name?: string;
    uri?: string;
    placeActionType?: string;
});

export type CreateGoogleBusinessPlaceActionError = (ErrorResponse);

export type DeleteGoogleBusinessPlaceActionData = {
    path: {
        accountId: string;
    };
    query: {
        /**
         * The resource name of the place action link (e.g. locations/123/placeActionLinks/456)
         */
        name: string;
    };
};

export type DeleteGoogleBusinessPlaceActionResponse = ({
    success?: boolean;
    deleted?: boolean;
    name?: string;
});

export type DeleteGoogleBusinessPlaceActionError = (ErrorResponse);

export type GetPendingOAuthDataData = {
    query: {
        /**
         * The pending data token from the OAuth redirect URL (pendingDataToken parameter)
         */
        token: string;
    };
};

export type GetPendingOAuthDataResponse = ({
    /**
     * The platform (e.g., "linkedin")
     */
    platform?: string;
    /**
     * The Late profile ID
     */
    profileId?: string;
    /**
     * Temporary access token for the platform
     */
    tempToken?: string;
    /**
     * Refresh token (if available)
     */
    refreshToken?: string;
    /**
     * Token expiry in seconds
     */
    expiresIn?: number;
    /**
     * User profile data (id, username, displayName, profilePicture)
     */
    userProfile?: {
        [key: string]: unknown;
    };
    /**
     * Type of selection data
     */
    selectionType?: 'organizations' | 'pages' | 'boards' | 'locations' | 'profiles';
    /**
     * LinkedIn organizations (when selectionType is "organizations")
     */
    organizations?: Array<{
        id?: string;
        urn?: string;
        name?: string;
        vanityName?: string;
    }>;
});

export type GetPendingOAuthDataError = (ErrorResponse);

export type ListLinkedInOrganizationsData = {
    query: {
        /**
         * Comma-separated list of organization IDs to fetch details for (max 100)
         */
        orgIds: string;
        /**
         * The temporary LinkedIn access token from the OAuth redirect
         */
        tempToken: string;
    };
};

export type ListLinkedInOrganizationsResponse = ({
    organizations?: Array<{
        /**
         * Organization ID
         */
        id?: string;
        /**
         * Logo URL (may be absent if no logo)
         */
        logoUrl?: string;
        /**
         * Organization's vanity name/slug
         */
        vanityName?: string;
        /**
         * Organization's website URL
         */
        website?: string;
        /**
         * Organization's primary industry
         */
        industry?: string;
        /**
         * Organization's description
         */
        description?: string;
    }>;
});

export type ListLinkedInOrganizationsError = ({
    error?: string;
} | unknown);

export type SelectLinkedInOrganizationData = {
    body: {
        profileId: string;
        tempToken: string;
        userProfile: {
            [key: string]: unknown;
        };
        accountType: 'personal' | 'organization';
        selectedOrganization?: {
            [key: string]: unknown;
        };
        redirect_url?: string;
    };
};

export type SelectLinkedInOrganizationResponse = ({
    message?: string;
    /**
     * The redirect URL with connection params appended (only if redirect_url was provided in request)
     */
    redirect_url?: string;
    account?: {
        /**
         * ID of the created SocialAccount
         */
        accountId?: string;
        platform?: 'linkedin';
        username?: string;
        displayName?: string;
        profilePicture?: string;
        isActive?: boolean;
        accountType?: 'personal' | 'organization';
    };
    bulkRefresh?: {
        updatedCount?: number;
        errors?: number;
    };
});

export type SelectLinkedInOrganizationError = (unknown | {
    error?: string;
});

export type ListPinterestBoardsForSelectionData = {
    headers: {
        /**
         * Short-lived connect token from the OAuth redirect
         */
        'X-Connect-Token': string;
    };
    query: {
        /**
         * Your Late profile ID
         */
        profileId: string;
        /**
         * Temporary Pinterest access token from the OAuth callback redirect
         */
        tempToken: string;
    };
};

export type ListPinterestBoardsForSelectionResponse = ({
    boards?: Array<{
        /**
         * Pinterest Board ID
         */
        id?: string;
        /**
         * Board name
         */
        name?: string;
        /**
         * Board description
         */
        description?: string;
        /**
         * Board privacy setting
         */
        privacy?: string;
    }>;
});

export type ListPinterestBoardsForSelectionError = (unknown | {
    error?: string;
});

export type SelectPinterestBoardData = {
    body: {
        /**
         * Your Late profile ID
         */
        profileId: string;
        /**
         * The Pinterest Board ID selected by the user
         */
        boardId: string;
        /**
         * The board name (for display purposes)
         */
        boardName?: string;
        /**
         * Temporary Pinterest access token from OAuth
         */
        tempToken: string;
        /**
         * User profile data from OAuth redirect
         */
        userProfile?: {
            [key: string]: unknown;
        };
        /**
         * Pinterest refresh token (if available)
         */
        refreshToken?: string;
        /**
         * Token expiration time in seconds
         */
        expiresIn?: number;
        /**
         * Custom redirect URL after connection completes
         */
        redirect_url?: string;
    };
};

export type SelectPinterestBoardResponse = ({
    message?: string;
    /**
     * Redirect URL with connection params (if provided)
     */
    redirect_url?: string;
    account?: {
        /**
         * ID of the created SocialAccount
         */
        accountId?: string;
        platform?: 'pinterest';
        username?: string;
        displayName?: string;
        profilePicture?: string;
        isActive?: boolean;
        defaultBoardName?: string;
    };
});

export type SelectPinterestBoardError = (unknown | {
    error?: string;
});

export type ListSnapchatProfilesData = {
    headers: {
        /**
         * Short-lived connect token from the OAuth redirect
         */
        'X-Connect-Token': string;
    };
    query: {
        /**
         * Your Late profile ID
         */
        profileId: string;
        /**
         * Temporary Snapchat access token from the OAuth callback redirect
         */
        tempToken: string;
    };
};

export type ListSnapchatProfilesResponse = ({
    publicProfiles?: Array<{
        /**
         * Snapchat Public Profile ID
         */
        id?: string;
        /**
         * Public profile display name
         */
        display_name?: string;
        /**
         * Public profile username/handle
         */
        username?: string;
        /**
         * Profile image URL
         */
        profile_image_url?: string;
        /**
         * Number of subscribers
         */
        subscriber_count?: number;
    }>;
});

export type ListSnapchatProfilesError = (unknown | {
    error?: string;
});

export type SelectSnapchatProfileData = {
    body: {
        /**
         * Your Late profile ID
         */
        profileId: string;
        /**
         * The selected Snapchat Public Profile
         */
        selectedPublicProfile: {
            /**
             * Snapchat Public Profile ID
             */
            id: string;
            /**
             * Display name of the public profile
             */
            display_name: string;
            /**
             * Username/handle
             */
            username?: string;
            /**
             * Profile image URL
             */
            profile_image_url?: string;
            /**
             * Number of subscribers
             */
            subscriber_count?: number;
        };
        /**
         * Temporary Snapchat access token from OAuth
         */
        tempToken: string;
        /**
         * User profile data from OAuth redirect
         */
        userProfile: {
            [key: string]: unknown;
        };
        /**
         * Snapchat refresh token (if available)
         */
        refreshToken?: string;
        /**
         * Token expiration time in seconds
         */
        expiresIn?: number;
        /**
         * Custom redirect URL after connection completes
         */
        redirect_url?: string;
    };
    headers?: {
        /**
         * Short-lived connect token from the OAuth redirect (for API users)
         */
        'X-Connect-Token'?: string;
    };
};

export type SelectSnapchatProfileResponse = ({
    message?: string;
    /**
     * Redirect URL with connection params (if provided in request)
     */
    redirect_url?: string;
    account?: {
        /**
         * ID of the created SocialAccount
         */
        accountId?: string;
        platform?: 'snapchat';
        username?: string;
        displayName?: string;
        profilePicture?: string;
        isActive?: boolean;
        publicProfileName?: string;
    };
});

export type SelectSnapchatProfileError = (unknown | {
    error?: string;
});

export type ConnectBlueskyCredentialsData = {
    body: {
        /**
         * Your Bluesky handle (e.g. user.bsky.social) or email address
         */
        identifier: string;
        /**
         * App password generated from Bluesky Settings > App Passwords
         */
        appPassword: string;
        /**
         * Required state formatted as {userId}-{profileId}. Get userId from GET /v1/users and profileId from GET /v1/profiles.
         */
        state: string;
        /**
         * Optional URL to redirect to after successful connection
         */
        redirectUri?: string;
    };
};

export type ConnectBlueskyCredentialsResponse = ({
    message?: string;
    account?: SocialAccount;
});

export type ConnectBlueskyCredentialsError = (unknown | {
    error?: string;
});

export type GetTelegramConnectStatusData = {
    query: {
        /**
         * The profile ID to connect the Telegram account to
         */
        profileId: string;
    };
};

export type GetTelegramConnectStatusResponse = ({
    /**
     * The access code to send to the Telegram bot
     */
    code?: string;
    /**
     * When the code expires
     */
    expiresAt?: string;
    /**
     * Seconds until expiration
     */
    expiresIn?: number;
    /**
     * The Telegram bot username to message
     */
    botUsername?: string;
    /**
     * Step-by-step connection instructions
     */
    instructions?: Array<(string)>;
});

export type GetTelegramConnectStatusError = (unknown | {
    error?: string;
});

export type InitiateTelegramConnectData = {
    body: {
        /**
         * The Telegram chat ID. Numeric ID (e.g. "-1001234567890") or username with @ prefix (e.g. "@mychannel").
         */
        chatId: string;
        /**
         * The profile ID to connect the account to
         */
        profileId: string;
    };
};

export type InitiateTelegramConnectResponse = ({
    message?: string;
    account?: {
        _id?: string;
        platform?: 'telegram';
        username?: string;
        displayName?: string;
        isActive?: boolean;
        chatType?: 'channel' | 'group' | 'supergroup' | 'private';
    };
});

export type InitiateTelegramConnectError = (unknown | {
    error?: string;
});

export type CompleteTelegramConnectData = {
    query: {
        /**
         * The access code to check status for
         */
        code: string;
    };
};

export type CompleteTelegramConnectResponse = (({
    status?: 'pending';
    expiresAt?: string;
    /**
     * Seconds until expiration
     */
    expiresIn?: number;
} | {
    status?: 'connected';
    chatId?: string;
    chatTitle?: string;
    chatType?: 'channel' | 'group' | 'supergroup';
    account?: {
        _id?: string;
        platform?: string;
        username?: string;
        displayName?: string;
    };
} | {
    status?: 'expired';
    message?: string;
}));

export type CompleteTelegramConnectError = ({
    error?: string;
} | unknown);

export type GetFacebookPagesData = {
    path: {
        accountId: string;
    };
};

export type GetFacebookPagesResponse = ({
    pages?: Array<{
        id?: string;
        name?: string;
        username?: string;
        category?: string;
        fan_count?: number;
    }>;
    selectedPageId?: string;
    cached?: boolean;
});

export type GetFacebookPagesError = ({
    error?: string;
} | unknown);

export type UpdateFacebookPageData = {
    body: {
        selectedPageId: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdateFacebookPageResponse = ({
    message?: string;
    selectedPage?: {
        id?: string;
        name?: string;
    };
});

export type UpdateFacebookPageError = (unknown | {
    error?: string;
});

export type GetLinkedInOrganizationsData = {
    path: {
        accountId: string;
    };
};

export type GetLinkedInOrganizationsResponse = ({
    organizations?: Array<{
        id?: string;
        name?: string;
        vanityName?: string;
        localizedName?: string;
    }>;
});

export type GetLinkedInOrganizationsError = ({
    error?: string;
} | unknown);

export type GetLinkedInAggregateAnalyticsData = {
    path: {
        /**
         * The ID of the LinkedIn personal account
         */
        accountId: string;
    };
    query?: {
        /**
         * TOTAL (default, lifetime totals) or DAILY (time series). MEMBERS_REACHED not available with DAILY.
         */
        aggregation?: 'TOTAL' | 'DAILY';
        /**
         * End date (YYYY-MM-DD, exclusive). Defaults to today if omitted.
         */
        endDate?: string;
        /**
         * Comma-separated metrics: IMPRESSION, MEMBERS_REACHED, REACTION, COMMENT, RESHARE. Omit for all.
         */
        metrics?: string;
        /**
         * Start date (YYYY-MM-DD). If omitted, returns lifetime analytics.
         */
        startDate?: string;
    };
};

export type GetLinkedInAggregateAnalyticsResponse = ((LinkedInAggregateAnalyticsTotalResponse | LinkedInAggregateAnalyticsDailyResponse));

export type GetLinkedInAggregateAnalyticsError = ({
    error?: string;
    code?: string;
    validOptions?: Array<(string)>;
} | {
    error?: string;
} | {
    error?: string;
    code?: string;
} | {
    error?: string;
    code?: string;
    requiredScope?: string;
    action?: string;
} | unknown);

export type GetLinkedInPostAnalyticsData = {
    path: {
        /**
         * The ID of the LinkedIn account
         */
        accountId: string;
    };
    query: {
        /**
         * The LinkedIn post URN
         */
        urn: string;
    };
};

export type GetLinkedInPostAnalyticsResponse = ({
    accountId?: string;
    platform?: string;
    accountType?: 'personal' | 'organization';
    username?: string;
    postUrn?: string;
    analytics?: {
        /**
         * Times the post was shown
         */
        impressions?: number;
        /**
         * Unique members who saw the post
         */
        reach?: number;
        /**
         * Reactions on the post
         */
        likes?: number;
        /**
         * Comments on the post
         */
        comments?: number;
        /**
         * Reshares of the post
         */
        shares?: number;
        /**
         * Clicks on the post (organization accounts only)
         */
        clicks?: number;
        /**
         * Video views (video posts only)
         */
        views?: number;
        /**
         * Engagement rate as percentage
         */
        engagementRate?: number;
    };
    lastUpdated?: string;
});

export type GetLinkedInPostAnalyticsError = ({
    error?: string;
    code?: 'missing_urn' | 'invalid_urn' | 'invalid_platform';
} | {
    error?: string;
} | unknown | {
    error?: string;
    code?: string;
    requiredScope?: string;
    action?: string;
} | {
    error?: string;
    code?: string;
});

export type UpdateLinkedInOrganizationData = {
    body: {
        accountType: 'personal' | 'organization';
        selectedOrganization?: {
            [key: string]: unknown;
        };
    };
    path: {
        accountId: string;
    };
};

export type UpdateLinkedInOrganizationResponse = ({
    message?: string;
    account?: SocialAccount;
});

export type UpdateLinkedInOrganizationError = (unknown | {
    error?: string;
});

export type GetLinkedInMentionsData = {
    path: {
        /**
         * The LinkedIn account ID
         */
        accountId: string;
    };
    query: {
        /**
         * Exact display name as shown on LinkedIn. Required for person mentions to be clickable. Optional for org mentions.
         */
        displayName?: string;
        /**
         * LinkedIn profile URL, company URL, or vanity name.
         */
        url: string;
    };
};

export type GetLinkedInMentionsResponse = ({
    /**
     * The LinkedIn URN (person or organization)
     */
    urn?: string;
    /**
     * The type of entity (person or organization)
     */
    type?: 'person' | 'organization';
    /**
     * Display name (provided, from API, or derived from vanity URL)
     */
    displayName?: string;
    /**
     * Ready-to-use mention format for post content
     */
    mentionFormat?: string;
    /**
     * The vanity name/slug (only for organization mentions)
     */
    vanityName?: string;
    /**
     * Warning about clickable mentions (only present for person mentions if displayName was not provided)
     */
    warning?: string;
});

export type GetLinkedInMentionsError = ({
    error?: string;
});

export type GetPinterestBoardsData = {
    path: {
        accountId: string;
    };
};

export type GetPinterestBoardsResponse = ({
    boards?: Array<{
        id?: string;
        name?: string;
        description?: string;
        privacy?: string;
    }>;
});

export type GetPinterestBoardsError = (unknown | {
    error?: string;
});

export type UpdatePinterestBoardsData = {
    body: {
        defaultBoardId: string;
        defaultBoardName?: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdatePinterestBoardsResponse = ({
    message?: string;
    account?: SocialAccount;
});

export type UpdatePinterestBoardsError = (unknown | {
    error?: string;
});

export type GetGmbLocationsData = {
    path: {
        accountId: string;
    };
};

export type GetGmbLocationsResponse = ({
    locations?: Array<{
        id?: string;
        name?: string;
        accountId?: string;
        accountName?: string;
        address?: string;
        category?: string;
        websiteUrl?: string;
    }>;
    selectedLocationId?: string;
    cached?: boolean;
});

export type GetGmbLocationsError = ({
    error?: string;
} | unknown);

export type UpdateGmbLocationData = {
    body: {
        selectedLocationId: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdateGmbLocationResponse = ({
    message?: string;
    selectedLocation?: {
        id?: string;
        name?: string;
    };
});

export type UpdateGmbLocationError = (unknown | {
    error?: string;
});

export type GetRedditSubredditsData = {
    path: {
        accountId: string;
    };
};

export type GetRedditSubredditsResponse = ({
    subreddits?: Array<{
        /**
         * Reddit subreddit ID
         */
        id?: string;
        /**
         * Subreddit name without r/ prefix
         */
        name?: string;
        /**
         * Subreddit title
         */
        title?: string;
        /**
         * Subreddit URL path
         */
        url?: string;
        /**
         * Whether the subreddit is NSFW
         */
        over18?: boolean;
    }>;
    /**
     * Currently set default subreddit for posting
     */
    defaultSubreddit?: string;
});

export type GetRedditSubredditsError = (unknown | {
    error?: string;
});

export type UpdateRedditSubredditsData = {
    body: {
        defaultSubreddit: string;
    };
    path: {
        accountId: string;
    };
};

export type UpdateRedditSubredditsResponse = ({
    success?: boolean;
});

export type UpdateRedditSubredditsError = (unknown | {
    error?: string;
});

export type GetRedditFlairsData = {
    path: {
        accountId: string;
    };
    query: {
        /**
         * Subreddit name (without "r/" prefix) to fetch flairs for
         */
        subreddit: string;
    };
};

export type GetRedditFlairsResponse = ({
    flairs?: Array<{
        /**
         * Flair ID to pass as flairId in platformSpecificData
         */
        id?: string;
        /**
         * Flair display text
         */
        text?: string;
        /**
         * Text color: 'dark' or 'light'
         */
        textColor?: string;
        /**
         * Background hex color (e.g. '#ff4500')
         */
        backgroundColor?: string;
    }>;
});

export type GetRedditFlairsError = (unknown | {
    error?: string;
});

export type ListQueueSlotsData = {
    query: {
        /**
         * Set to 'true' to list all queues for the profile
         */
        all?: 'true';
        /**
         * Profile ID to get queues for
         */
        profileId: string;
        /**
         * Specific queue ID to retrieve (optional)
         */
        queueId?: string;
    };
};

export type ListQueueSlotsResponse = (({
    exists?: boolean;
    schedule?: QueueSchedule;
    nextSlots?: Array<(string)>;
} | {
    queues?: Array<QueueSchedule>;
    count?: number;
}));

export type ListQueueSlotsError = (unknown | {
    error?: string;
});

export type CreateQueueSlotData = {
    body: {
        /**
         * Profile ID
         */
        profileId: string;
        /**
         * Queue name (e.g., Evening Posts)
         */
        name: string;
        /**
         * IANA timezone
         */
        timezone: string;
        slots: Array<QueueSlot>;
        active?: boolean;
    };
};

export type CreateQueueSlotResponse = ({
    success?: boolean;
    schedule?: QueueSchedule;
    nextSlots?: Array<(string)>;
});

export type CreateQueueSlotError = (unknown | {
    error?: string;
});

export type UpdateQueueSlotData = {
    body: {
        profileId: string;
        /**
         * Queue ID to update (optional)
         */
        queueId?: string;
        /**
         * Queue name
         */
        name?: string;
        timezone: string;
        slots: Array<QueueSlot>;
        active?: boolean;
        /**
         * Make this queue the default
         */
        setAsDefault?: boolean;
        /**
         * Whether to reschedule existing queued posts to match new slots
         */
        reshuffleExisting?: boolean;
    };
};

export type UpdateQueueSlotResponse = ({
    success?: boolean;
    schedule?: QueueSchedule;
    nextSlots?: Array<(string)>;
    reshuffledCount?: number;
});

export type UpdateQueueSlotError = (unknown | {
    error?: string;
});

export type DeleteQueueSlotData = {
    query: {
        profileId: string;
        /**
         * Queue ID to delete
         */
        queueId: string;
    };
};

export type DeleteQueueSlotResponse = ({
    success?: boolean;
    deleted?: boolean;
});

export type DeleteQueueSlotError = (unknown | {
    error?: string;
});

export type PreviewQueueData = {
    query: {
        count?: number;
        profileId: string;
    };
};

export type PreviewQueueResponse = ({
    profileId?: string;
    count?: number;
    slots?: Array<(string)>;
});

export type PreviewQueueError = (unknown | {
    error?: string;
});

export type GetNextQueueSlotData = {
    query: {
        profileId: string;
        /**
         * Specific queue ID (optional, defaults to profile's default queue)
         */
        queueId?: string;
    };
};

export type GetNextQueueSlotResponse = ({
    profileId?: string;
    nextSlot?: string;
    timezone?: string;
    /**
     * Queue ID this slot belongs to
     */
    queueId?: string;
    /**
     * Queue name
     */
    queueName?: string;
});

export type GetNextQueueSlotError = (unknown | {
    error?: string;
});

export type GetWebhookSettingsResponse = ({
    webhooks?: Array<Webhook>;
});

export type GetWebhookSettingsError = ({
    error?: string;
});

export type CreateWebhookSettingsData = {
    body: {
        /**
         * Webhook name (max 50 characters)
         */
        name?: string;
        /**
         * Webhook endpoint URL (must be HTTPS in production)
         */
        url?: string;
        /**
         * Secret key for HMAC-SHA256 signature verification
         */
        secret?: string;
        /**
         * Events to subscribe to
         */
        events?: Array<('post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received' | 'comment.received')>;
        /**
         * Enable or disable webhook delivery
         */
        isActive?: boolean;
        /**
         * Custom headers to include in webhook requests
         */
        customHeaders?: {
            [key: string]: (string);
        };
    };
};

export type CreateWebhookSettingsResponse = ({
    success?: boolean;
    webhook?: Webhook;
});

export type CreateWebhookSettingsError = (unknown | {
    error?: string;
});

export type UpdateWebhookSettingsData = {
    body: {
        /**
         * Webhook ID to update (required)
         */
        _id: string;
        /**
         * Webhook name (max 50 characters)
         */
        name?: string;
        /**
         * Webhook endpoint URL (must be HTTPS in production)
         */
        url?: string;
        /**
         * Secret key for HMAC-SHA256 signature verification
         */
        secret?: string;
        /**
         * Events to subscribe to
         */
        events?: Array<('post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received' | 'comment.received')>;
        /**
         * Enable or disable webhook delivery
         */
        isActive?: boolean;
        /**
         * Custom headers to include in webhook requests
         */
        customHeaders?: {
            [key: string]: (string);
        };
    };
};

export type UpdateWebhookSettingsResponse = ({
    success?: boolean;
    webhook?: Webhook;
});

export type UpdateWebhookSettingsError = (unknown | {
    error?: string;
});

export type DeleteWebhookSettingsData = {
    query: {
        /**
         * Webhook ID to delete
         */
        id: string;
    };
};

export type DeleteWebhookSettingsResponse = ({
    success?: boolean;
});

export type DeleteWebhookSettingsError = (unknown | {
    error?: string;
});

export type TestWebhookData = {
    body: {
        /**
         * ID of the webhook to test
         */
        webhookId: string;
    };
};

export type TestWebhookResponse = ({
    success?: boolean;
    message?: string;
});

export type TestWebhookError = (unknown | {
    error?: string;
} | {
    success?: boolean;
    message?: string;
});

export type GetWebhookLogsData = {
    query?: {
        /**
         * Filter by event type
         */
        event?: 'post.scheduled' | 'post.published' | 'post.failed' | 'post.partial' | 'account.connected' | 'account.disconnected' | 'message.received' | 'comment.received' | 'webhook.test';
        /**
         * Maximum number of logs to return (max 100)
         */
        limit?: number;
        /**
         * Filter by delivery status
         */
        status?: 'success' | 'failed';
        /**
         * Filter by webhook ID
         */
        webhookId?: string;
    };
};

export type GetWebhookLogsResponse = ({
    logs?: Array<WebhookLog>;
});

export type GetWebhookLogsError = ({
    error?: string;
});

export type ListPostsLogsData = {
    query?: {
        /**
         * Filter by action type
         */
        action?: 'publish' | 'retry' | 'media_upload' | 'rate_limit_pause' | 'token_refresh' | 'cancelled' | 'all';
        /**
         * Number of days to look back (max 7)
         */
        days?: number;
        /**
         * Maximum number of logs to return (max 100)
         */
        limit?: number;
        /**
         * Filter by platform
         */
        platform?: 'tiktok' | 'instagram' | 'facebook' | 'youtube' | 'linkedin' | 'twitter' | 'threads' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat' | 'all';
        /**
         * Number of logs to skip (for pagination)
         */
        skip?: number;
        /**
         * Filter by log status
         */
        status?: 'success' | 'failed' | 'pending' | 'skipped' | 'all';
    };
};

export type ListPostsLogsResponse = ({
    logs?: Array<PostLog>;
    pagination?: {
        /**
         * Total number of logs matching the query
         */
        total?: number;
        limit?: number;
        skip?: number;
        /**
         * Total number of pages
         */
        pages?: number;
        hasMore?: boolean;
    };
});

export type ListPostsLogsError = ({
    error?: string;
});

export type ListConnectionLogsData = {
    query?: {
        /**
         * Number of days to look back (max 7)
         */
        days?: number;
        /**
         * Filter by event type
         */
        eventType?: 'connect_success' | 'connect_failed' | 'disconnect' | 'reconnect_success' | 'reconnect_failed' | 'all';
        /**
         * Maximum number of logs to return (max 100)
         */
        limit?: number;
        /**
         * Filter by platform
         */
        platform?: 'tiktok' | 'instagram' | 'facebook' | 'youtube' | 'linkedin' | 'twitter' | 'threads' | 'pinterest' | 'reddit' | 'bluesky' | 'googlebusiness' | 'telegram' | 'snapchat' | 'all';
        /**
         * Number of logs to skip (for pagination)
         */
        skip?: number;
        /**
         * Filter by status (shorthand for event types)
         */
        status?: 'success' | 'failed' | 'all';
    };
};

export type ListConnectionLogsResponse = ({
    logs?: Array<ConnectionLog>;
    pagination?: {
        /**
         * Total number of logs matching the query
         */
        total?: number;
        limit?: number;
        skip?: number;
        /**
         * Total number of pages
         */
        pages?: number;
        hasMore?: boolean;
    };
});

export type ListConnectionLogsError = ({
    error?: string;
});

export type GetPostLogsData = {
    path: {
        /**
         * The post ID
         */
        postId: string;
    };
    query?: {
        /**
         * Maximum number of logs to return (max 100)
         */
        limit?: number;
    };
};

export type GetPostLogsResponse = ({
    logs?: Array<PostLog>;
    /**
     * Number of logs returned
     */
    count?: number;
    postId?: string;
});

export type GetPostLogsError = ({
    error?: string;
} | unknown);

export type ListInboxConversationsData = {
    query?: {
        /**
         * Filter by specific social account ID
         */
        accountId?: string;
        /**
         * Pagination cursor for next page
         */
        cursor?: string;
        /**
         * Maximum number of conversations to return
         */
        limit?: number;
        /**
         * Filter by platform
         */
        platform?: 'facebook' | 'instagram' | 'twitter' | 'bluesky' | 'reddit' | 'telegram';
        /**
         * Filter by profile ID
         */
        profileId?: string;
        /**
         * Sort order by updated time
         */
        sortOrder?: 'asc' | 'desc';
        /**
         * Filter by conversation status
         */
        status?: 'active' | 'archived';
    };
};

export type ListInboxConversationsResponse = ({
    data?: Array<{
        id?: string;
        platform?: string;
        accountId?: string;
        accountUsername?: string;
        participantId?: string;
        participantName?: string;
        participantPicture?: (string) | null;
        lastMessage?: string;
        updatedTime?: string;
        status?: 'active' | 'archived';
        /**
         * Number of unread messages
         */
        unreadCount?: (number) | null;
        /**
         * Direct link to open the conversation on the platform (if available)
         */
        url?: (string) | null;
        /**
         * Instagram profile data for the participant. Only present for Instagram conversations.
         */
        instagramProfile?: {
            /**
             * Whether the participant follows your Instagram business account
             */
            isFollower?: (boolean) | null;
            /**
             * Whether your Instagram business account follows the participant
             */
            isFollowing?: (boolean) | null;
            /**
             * The participant's follower count on Instagram
             */
            followerCount?: (number) | null;
            /**
             * Whether the participant is a verified Instagram user
             */
            isVerified?: (boolean) | null;
            /**
             * When this profile data was last fetched from Instagram
             */
            fetchedAt?: (string) | null;
        } | null;
    }>;
    pagination?: {
        hasMore?: boolean;
        nextCursor?: (string) | null;
    };
    meta?: {
        accountsQueried?: number;
        accountsFailed?: number;
        failedAccounts?: Array<{
            accountId?: string;
            accountUsername?: (string) | null;
            platform?: string;
            error?: string;
            /**
             * Error code if available
             */
            code?: (string) | null;
            /**
             * Seconds to wait before retry (rate limits)
             */
            retryAfter?: (number) | null;
        }>;
        lastUpdated?: string;
    };
});

export type ListInboxConversationsError = ({
    error?: string;
} | unknown);

export type GetInboxConversationData = {
    path: {
        /**
         * The conversation ID (id field from list conversations endpoint). This is the platform-specific conversation identifier, not an internal database ID.
         */
        conversationId: string;
    };
    query: {
        /**
         * The social account ID
         */
        accountId: string;
    };
};

export type GetInboxConversationResponse = ({
    data?: {
        id?: string;
        accountId?: string;
        accountUsername?: string;
        platform?: string;
        status?: 'active' | 'archived';
        participantName?: string;
        participantId?: string;
        lastMessage?: string;
        lastMessageAt?: string;
        updatedTime?: string;
        participants?: Array<{
            id?: string;
            name?: string;
        }>;
        /**
         * Instagram profile data for the participant. Only present for Instagram conversations.
         */
        instagramProfile?: {
            /**
             * Whether the participant follows your Instagram business account
             */
            isFollower?: (boolean) | null;
            /**
             * Whether your Instagram business account follows the participant
             */
            isFollowing?: (boolean) | null;
            /**
             * The participant's follower count on Instagram
             */
            followerCount?: (number) | null;
            /**
             * Whether the participant is a verified Instagram user
             */
            isVerified?: (boolean) | null;
            /**
             * When this profile data was last fetched from Instagram
             */
            fetchedAt?: (string) | null;
        } | null;
    };
});

export type GetInboxConversationError = ({
    error?: string;
} | unknown);

export type UpdateInboxConversationData = {
    body: {
        /**
         * Social account ID
         */
        accountId: string;
        status: 'active' | 'archived';
    };
    path: {
        /**
         * The conversation ID (id field from list conversations endpoint). This is the platform-specific conversation identifier, not an internal database ID.
         */
        conversationId: string;
    };
};

export type UpdateInboxConversationResponse = ({
    success?: boolean;
    data?: {
        id?: string;
        accountId?: string;
        status?: 'active' | 'archived';
        platform?: string;
        updatedAt?: string;
    };
});

export type UpdateInboxConversationError = ({
    error?: string;
} | unknown);

export type GetInboxConversationMessagesData = {
    path: {
        /**
         * The conversation ID (id field from list conversations endpoint). This is the platform-specific conversation identifier, not an internal database ID.
         */
        conversationId: string;
    };
    query: {
        /**
         * Social account ID
         */
        accountId: string;
    };
};

export type GetInboxConversationMessagesResponse = ({
    status?: string;
    messages?: Array<{
        id?: string;
        conversationId?: string;
        accountId?: string;
        platform?: string;
        message?: string;
        senderId?: string;
        senderName?: (string) | null;
        direction?: 'incoming' | 'outgoing';
        createdAt?: string;
        attachments?: Array<{
            id?: string;
            type?: 'image' | 'video' | 'audio' | 'file' | 'sticker' | 'share';
            url?: string;
            filename?: (string) | null;
            previewUrl?: (string) | null;
        }>;
        /**
         * Reddit message subject
         */
        subject?: (string) | null;
        /**
         * Instagram story reply
         */
        storyReply?: (boolean) | null;
        /**
         * Instagram story mention
         */
        isStoryMention?: (boolean) | null;
    }>;
    lastUpdated?: string;
});

export type GetInboxConversationMessagesError = ({
    error?: string;
} | unknown);

export type SendInboxMessageData = {
    body: {
        /**
         * Social account ID
         */
        accountId: string;
        /**
         * Message text
         */
        message?: string;
        /**
         * Quick reply buttons. Mutually exclusive with buttons. Max 13 items.
         */
        quickReplies?: Array<{
            /**
             * Button label (max 20 chars)
             */
            title: string;
            /**
             * Payload sent back on tap
             */
            payload: string;
            /**
             * Optional icon URL (Meta only)
             */
            imageUrl?: string;
        }>;
        /**
         * Action buttons. Mutually exclusive with quickReplies. Max 3 items.
         */
        buttons?: Array<{
            /**
             * Button type. phone is Facebook only.
             */
            type: 'url' | 'postback' | 'phone';
            /**
             * Button label (max 20 chars)
             */
            title: string;
            /**
             * URL for url-type buttons
             */
            url?: string;
            /**
             * Payload for postback-type buttons
             */
            payload?: string;
            /**
             * Phone number for phone-type buttons (Facebook only)
             */
            phone?: string;
        }>;
        /**
         * Generic template for carousels (Instagram/Facebook only, ignored on Telegram).
         */
        template?: {
            /**
             * Template type
             */
            type?: 'generic';
            elements?: Array<{
                /**
                 * Element title (max 80 chars)
                 */
                title: string;
                /**
                 * Element subtitle
                 */
                subtitle?: string;
                /**
                 * Element image URL
                 */
                imageUrl?: string;
                buttons?: Array<{
                    type?: 'url' | 'postback';
                    title?: string;
                    url?: string;
                    payload?: string;
                }>;
            }>;
        };
        /**
         * Telegram-native keyboard markup. Ignored on other platforms.
         */
        replyMarkup?: {
            /**
             * Keyboard type
             */
            type?: 'inline_keyboard' | 'reply_keyboard';
            /**
             * Array of rows, each row is an array of buttons
             */
            keyboard?: Array<Array<{
                /**
                 * Button text
                 */
                text?: string;
                /**
                 * Callback data (inline_keyboard only
                 */
                callbackData?: string;
                /**
                 * URL to open (inline_keyboard only)
                 */
                url?: string;
            }>>;
            /**
             * Hide keyboard after use (reply_keyboard only)
             */
            oneTime?: boolean;
        };
        /**
         * Facebook messaging type. Required when using messageTag.
         */
        messagingType?: 'RESPONSE' | 'UPDATE' | 'MESSAGE_TAG';
        /**
         * Facebook message tag for messaging outside 24h window. Requires messagingType MESSAGE_TAG. Instagram only supports HUMAN_AGENT.
         */
        messageTag?: 'CONFIRMED_EVENT_UPDATE' | 'POST_PURCHASE_UPDATE' | 'ACCOUNT_UPDATE' | 'HUMAN_AGENT';
        /**
         * Platform message ID to reply to (Telegram only).
         */
        replyTo?: string;
    };
    path: {
        /**
         * The conversation ID (id field from list conversations endpoint). This is the platform-specific conversation identifier, not an internal database ID.
         */
        conversationId: string;
    };
};

export type SendInboxMessageResponse = ({
    success?: boolean;
    data?: {
        /**
         * ID of the sent message (not returned for Reddit)
         */
        messageId?: string;
        /**
         * Twitter conversation ID
         */
        conversationId?: (string) | null;
        /**
         * Bluesky sent timestamp
         */
        sentAt?: (string) | null;
        /**
         * Success message (Reddit only)
         */
        message?: (string) | null;
    };
});

export type SendInboxMessageError = ({
    error?: string;
    code?: 'PLATFORM_LIMITATION';
} | {
    error?: string;
} | unknown);

export type EditInboxMessageData = {
    body: {
        /**
         * Social account ID
         */
        accountId: string;
        /**
         * New message text
         */
        text?: string;
        /**
         * New inline keyboard markup
         */
        replyMarkup?: {
            type?: 'inline_keyboard';
            keyboard?: Array<Array<{
                text?: string;
                callbackData?: string;
                url?: string;
            }>>;
        };
    };
    path: {
        /**
         * The conversation ID
         */
        conversationId: string;
        /**
         * The Telegram message ID to edit
         */
        messageId: string;
    };
};

export type EditInboxMessageResponse = ({
    success?: boolean;
    data?: {
        messageId?: number;
    };
});

export type EditInboxMessageError = (unknown | {
    error?: string;
});

export type GetMessengerMenuData = {
    path: {
        accountId: string;
    };
};

export type GetMessengerMenuResponse = ({
    data?: Array<{
        [key: string]: unknown;
    }>;
});

export type GetMessengerMenuError = (unknown | {
    error?: string;
});

export type SetMessengerMenuData = {
    body: {
        /**
         * Persistent menu configuration array (Meta format)
         */
        persistent_menu: Array<{
            [key: string]: unknown;
        }>;
    };
    path: {
        accountId: string;
    };
};

export type SetMessengerMenuResponse = (unknown);

export type SetMessengerMenuError = (unknown | {
    error?: string;
});

export type DeleteMessengerMenuData = {
    path: {
        accountId: string;
    };
};

export type DeleteMessengerMenuResponse = (unknown);

export type DeleteMessengerMenuError = ({
    error?: string;
});

export type GetInstagramIceBreakersData = {
    path: {
        accountId: string;
    };
};

export type GetInstagramIceBreakersResponse = ({
    data?: Array<{
        [key: string]: unknown;
    }>;
});

export type GetInstagramIceBreakersError = (unknown | {
    error?: string;
});

export type SetInstagramIceBreakersData = {
    body: {
        ice_breakers: Array<{
            question: string;
            payload: string;
        }>;
    };
    path: {
        accountId: string;
    };
};

export type SetInstagramIceBreakersResponse = (unknown);

export type SetInstagramIceBreakersError = (unknown | {
    error?: string;
});

export type DeleteInstagramIceBreakersData = {
    path: {
        accountId: string;
    };
};

export type DeleteInstagramIceBreakersResponse = (unknown);

export type DeleteInstagramIceBreakersError = ({
    error?: string;
});

export type GetTelegramCommandsData = {
    path: {
        accountId: string;
    };
};

export type GetTelegramCommandsResponse = ({
    data?: Array<{
        command?: string;
        description?: string;
    }>;
});

export type GetTelegramCommandsError = (unknown | {
    error?: string;
});

export type SetTelegramCommandsData = {
    body: {
        commands: Array<{
            /**
             * Bot command without leading slash
             */
            command: string;
            /**
             * Command description
             */
            description: string;
        }>;
    };
    path: {
        accountId: string;
    };
};

export type SetTelegramCommandsResponse = (unknown);

export type SetTelegramCommandsError = (unknown | {
    error?: string;
});

export type DeleteTelegramCommandsData = {
    path: {
        accountId: string;
    };
};

export type DeleteTelegramCommandsResponse = (unknown);

export type DeleteTelegramCommandsError = ({
    error?: string;
});

export type ListInboxCommentsData = {
    query?: {
        /**
         * Filter by specific social account ID
         */
        accountId?: string;
        cursor?: string;
        limit?: number;
        /**
         * Minimum comment count
         */
        minComments?: number;
        /**
         * Filter by platform
         */
        platform?: 'facebook' | 'instagram' | 'twitter' | 'bluesky' | 'threads' | 'youtube' | 'linkedin' | 'reddit';
        /**
         * Filter by profile ID
         */
        profileId?: string;
        /**
         * Posts created after this date
         */
        since?: string;
        /**
         * Sort field
         */
        sortBy?: 'date' | 'comments';
        /**
         * Sort order
         */
        sortOrder?: 'asc' | 'desc';
    };
};

export type ListInboxCommentsResponse = ({
    data?: Array<{
        id?: string;
        platform?: string;
        accountId?: string;
        accountUsername?: string;
        content?: string;
        picture?: (string) | null;
        permalink?: (string) | null;
        createdTime?: string;
        commentCount?: number;
        likeCount?: number;
        /**
         * Bluesky content identifier
         */
        cid?: (string) | null;
        /**
         * Reddit subreddit name
         */
        subreddit?: (string) | null;
    }>;
    pagination?: {
        hasMore?: boolean;
        nextCursor?: (string) | null;
    };
    meta?: {
        accountsQueried?: number;
        accountsFailed?: number;
        failedAccounts?: Array<{
            accountId?: string;
            accountUsername?: (string) | null;
            platform?: string;
            error?: string;
            /**
             * Error code if available
             */
            code?: (string) | null;
            /**
             * Seconds to wait before retry (rate limits)
             */
            retryAfter?: (number) | null;
        }>;
        lastUpdated?: string;
    };
});

export type ListInboxCommentsError = ({
    error?: string;
} | unknown);

export type GetInboxPostCommentsData = {
    path: {
        /**
         * Late post ID or platform-specific post ID. Late IDs are auto-resolved. LinkedIn third-party posts accept full activity URN or numeric ID.
         */
        postId: string;
    };
    query: {
        accountId: string;
        /**
         * (Reddit only) Get replies to a specific comment
         */
        commentId?: string;
        /**
         * Pagination cursor
         */
        cursor?: string;
        /**
         * Maximum number of comments to return
         */
        limit?: number;
        /**
         * (Reddit only) Subreddit name
         */
        subreddit?: string;
    };
};

export type GetInboxPostCommentsResponse = ({
    status?: string;
    comments?: Array<{
        id?: string;
        message?: string;
        createdTime?: string;
        from?: {
            id?: string;
            name?: string;
            username?: string;
            picture?: (string) | null;
            isOwner?: boolean;
        };
        likeCount?: number;
        replyCount?: number;
        /**
         * The platform this comment is from
         */
        platform?: string;
        /**
         * Direct link to the comment on the platform (if available)
         */
        url?: (string) | null;
        replies?: Array<{
            [key: string]: unknown;
        }>;
        canReply?: boolean;
        canDelete?: boolean;
        /**
         * Whether this comment can be hidden (Facebook
         */
        canHide?: boolean;
        /**
         * Whether this comment can be liked (Facebook
         */
        canLike?: boolean;
        /**
         * Whether the comment is currently hidden
         */
        isHidden?: boolean;
        /**
         * Whether the current user has liked this comment
         */
        isLiked?: boolean;
        /**
         * Bluesky like URI for unliking
         */
        likeUri?: (string) | null;
        /**
         * Bluesky content identifier
         */
        cid?: (string) | null;
        /**
         * Parent comment ID for nested replies
         */
        parentId?: (string) | null;
        /**
         * Bluesky root post URI
         */
        rootUri?: (string) | null;
        /**
         * Bluesky root post CID
         */
        rootCid?: (string) | null;
    }>;
    pagination?: {
        hasMore?: boolean;
        cursor?: (string) | null;
    };
    meta?: {
        platform?: string;
        postId?: string;
        accountId?: string;
        /**
         * (Reddit only) Subreddit name
         */
        subreddit?: (string) | null;
        lastUpdated?: string;
    };
});

export type GetInboxPostCommentsError = ({
    error?: string;
} | unknown);

export type ReplyToInboxPostData = {
    body: {
        accountId: string;
        message: string;
        /**
         * Reply to specific comment (optional)
         */
        commentId?: string;
        /**
         * (Reddit only) Subreddit name for replies
         */
        subreddit?: string;
        /**
         * (Bluesky only) Parent content identifier
         */
        parentCid?: string;
        /**
         * (Bluesky only) Root post URI
         */
        rootUri?: string;
        /**
         * (Bluesky only) Root post CID
         */
        rootCid?: string;
    };
    path: {
        /**
         * Late post ID or platform-specific post ID. LinkedIn third-party posts accept full activity URN or numeric ID.
         */
        postId: string;
    };
};

export type ReplyToInboxPostResponse = ({
    success?: boolean;
    data?: {
        commentId?: string;
        isReply?: boolean;
        /**
         * Bluesky CID
         */
        cid?: (string) | null;
    };
});

export type ReplyToInboxPostError = ({
    error?: string;
} | unknown);

export type DeleteInboxCommentData = {
    path: {
        /**
         * Late post ID or platform-specific post ID. LinkedIn third-party posts accept full activity URN or numeric ID.
         */
        postId: string;
    };
    query: {
        accountId: string;
        commentId: string;
    };
};

export type DeleteInboxCommentResponse = ({
    success?: boolean;
    data?: {
        message?: string;
    };
});

export type DeleteInboxCommentError = ({
    error?: string;
} | unknown);

export type HideInboxCommentData = {
    body: {
        /**
         * The social account ID
         */
        accountId: string;
    };
    path: {
        commentId: string;
        postId: string;
    };
};

export type HideInboxCommentResponse = ({
    status?: string;
    commentId?: string;
    hidden?: boolean;
    platform?: string;
});

export type HideInboxCommentError = (unknown | {
    error?: string;
});

export type UnhideInboxCommentData = {
    path: {
        commentId: string;
        postId: string;
    };
    query: {
        accountId: string;
    };
};

export type UnhideInboxCommentResponse = ({
    status?: string;
    commentId?: string;
    hidden?: boolean;
    platform?: string;
});

export type UnhideInboxCommentError = (unknown | {
    error?: string;
});

export type LikeInboxCommentData = {
    body: {
        /**
         * The social account ID
         */
        accountId: string;
        /**
         * (Bluesky only) Content identifier for the comment
         */
        cid?: string;
    };
    path: {
        commentId: string;
        postId: string;
    };
};

export type LikeInboxCommentResponse = ({
    status?: string;
    commentId?: string;
    liked?: boolean;
    /**
     * (Bluesky only) URI to use for unliking
     */
    likeUri?: string;
    platform?: string;
});

export type LikeInboxCommentError = (unknown | {
    error?: string;
});

export type UnlikeInboxCommentData = {
    path: {
        commentId: string;
        postId: string;
    };
    query: {
        accountId: string;
        /**
         * (Bluesky only) The like URI returned when liking
         */
        likeUri?: string;
    };
};

export type UnlikeInboxCommentResponse = ({
    status?: string;
    commentId?: string;
    liked?: boolean;
    platform?: string;
});

export type UnlikeInboxCommentError = (unknown | {
    error?: string;
});

export type SendPrivateReplyToCommentData = {
    body: {
        /**
         * The social account ID (Instagram or Facebook)
         */
        accountId: string;
        /**
         * The message text to send as a private DM
         */
        message: string;
    };
    path: {
        /**
         * The comment ID to send a private reply to
         */
        commentId: string;
        /**
         * The media/post ID (Instagram media ID or Facebook post ID)
         */
        postId: string;
    };
};

export type SendPrivateReplyToCommentResponse = ({
    status?: string;
    /**
     * The ID of the sent message
     */
    messageId?: string;
    /**
     * The comment ID that was replied to
     */
    commentId?: string;
    platform?: 'instagram' | 'facebook';
});

export type SendPrivateReplyToCommentError = ({
    error?: string;
    code?: 'PLATFORM_LIMITATION';
} | {
    error?: string;
} | unknown);

export type ListInboxReviewsData = {
    query?: {
        /**
         * Filter by specific social account ID
         */
        accountId?: string;
        cursor?: string;
        /**
         * Filter by reply status
         */
        hasReply?: boolean;
        limit?: number;
        maxRating?: number;
        minRating?: number;
        platform?: 'facebook' | 'googlebusiness';
        profileId?: string;
        sortBy?: 'date' | 'rating';
        sortOrder?: 'asc' | 'desc';
    };
};

export type ListInboxReviewsResponse = ({
    status?: string;
    data?: Array<{
        id?: string;
        platform?: string;
        accountId?: string;
        accountUsername?: string;
        reviewer?: {
            id?: (string) | null;
            name?: string;
            profileImage?: (string) | null;
        };
        rating?: number;
        text?: string;
        created?: string;
        hasReply?: boolean;
        reply?: {
            id?: string;
            text?: string;
            created?: string;
        } | null;
        reviewUrl?: (string) | null;
    }>;
    pagination?: {
        hasMore?: boolean;
        nextCursor?: (string) | null;
    };
    meta?: {
        accountsQueried?: number;
        accountsFailed?: number;
        failedAccounts?: Array<{
            accountId?: string;
            accountUsername?: (string) | null;
            platform?: string;
            error?: string;
            /**
             * Error code if available
             */
            code?: (string) | null;
            /**
             * Seconds to wait before retry (rate limits)
             */
            retryAfter?: (number) | null;
        }>;
        lastUpdated?: string;
    };
    summary?: {
        totalReviews?: number;
        averageRating?: (number) | null;
    };
});

export type ListInboxReviewsError = ({
    error?: string;
} | unknown);

export type ReplyToInboxReviewData = {
    body: {
        accountId: string;
        message: string;
    };
    path: {
        /**
         * Review ID (URL-encoded for Google Business)
         */
        reviewId: string;
    };
};

export type ReplyToInboxReviewResponse = ({
    status?: string;
    reply?: {
        id?: string;
        text?: string;
        created?: string;
    };
    platform?: string;
});

export type ReplyToInboxReviewError = ({
    error?: string;
} | unknown);

export type DeleteInboxReviewReplyData = {
    body: {
        accountId: string;
    };
    path: {
        reviewId: string;
    };
};

export type DeleteInboxReviewReplyResponse = ({
    status?: string;
    message?: string;
    platform?: string;
});

export type DeleteInboxReviewReplyError = ({
    error?: string;
} | unknown);