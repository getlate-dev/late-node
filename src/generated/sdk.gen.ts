// This file is auto-generated by @hey-api/openapi-ts

import { createClient, createConfig, type OptionsLegacyParser, formDataBodySerializer } from '@hey-api/client-fetch';
import type { DownloadYouTubeVideoData, DownloadYouTubeVideoError, DownloadYouTubeVideoResponse, GetYouTubeTranscriptData, GetYouTubeTranscriptError, GetYouTubeTranscriptResponse, DownloadInstagramMediaData, DownloadInstagramMediaError, DownloadInstagramMediaResponse, CheckInstagramHashtagsData, CheckInstagramHashtagsError, CheckInstagramHashtagsResponse, DownloadTikTokVideoData, DownloadTikTokVideoError, DownloadTikTokVideoResponse, DownloadTwitterMediaData, DownloadTwitterMediaError, DownloadTwitterMediaResponse, DownloadFacebookVideoData, DownloadFacebookVideoError, DownloadFacebookVideoResponse, DownloadLinkedInVideoData, DownloadLinkedInVideoError, DownloadLinkedInVideoResponse, DownloadBlueskyMediaData, DownloadBlueskyMediaError, DownloadBlueskyMediaResponse, GetAnalyticsData, GetAnalyticsError, GetAnalyticsResponse, GetYouTubeDailyViewsData, GetYouTubeDailyViewsError, GetYouTubeDailyViewsResponse, ListAccountGroupsError, ListAccountGroupsResponse, CreateAccountGroupData, CreateAccountGroupError, CreateAccountGroupResponse, UpdateAccountGroupData, UpdateAccountGroupError, UpdateAccountGroupResponse, DeleteAccountGroupData, DeleteAccountGroupError, DeleteAccountGroupResponse, GetMediaPresignedUrlData, GetMediaPresignedUrlError, GetMediaPresignedUrlResponse, SearchRedditData, SearchRedditError, SearchRedditResponse, GetRedditFeedData, GetRedditFeedError, GetRedditFeedResponse, GetUsageStatsError, GetUsageStatsResponse, ListPostsData, ListPostsError, ListPostsResponse, CreatePostData, CreatePostError, CreatePostResponse, GetPostData, GetPostError, GetPostResponse, UpdatePostData, UpdatePostError, UpdatePostResponse, DeletePostData, DeletePostError, DeletePostResponse, BulkUploadPostsData, BulkUploadPostsError, BulkUploadPostsResponse, RetryPostData, RetryPostError, RetryPostResponse, UnpublishPostData, UnpublishPostError, UnpublishPostResponse, ListUsersError, ListUsersResponse, GetUserData, GetUserError, GetUserResponse, ListProfilesData, ListProfilesError, ListProfilesResponse, CreateProfileData, CreateProfileError, CreateProfileResponse, GetProfileData, GetProfileError, GetProfileResponse, UpdateProfileData, UpdateProfileError, UpdateProfileResponse, DeleteProfileData, DeleteProfileError, DeleteProfileResponse, ListAccountsData, ListAccountsError, ListAccountsResponse, GetFollowerStatsData, GetFollowerStatsError, GetFollowerStatsResponse, UpdateAccountData, UpdateAccountError, UpdateAccountResponse, DeleteAccountData, DeleteAccountError, DeleteAccountResponse, GetAllAccountsHealthData, GetAllAccountsHealthError, GetAllAccountsHealthResponse, GetAccountHealthData, GetAccountHealthError, GetAccountHealthResponse, ListApiKeysError, ListApiKeysResponse, CreateApiKeyData, CreateApiKeyError, CreateApiKeyResponse, DeleteApiKeyData, DeleteApiKeyError, DeleteApiKeyResponse, CreateInviteTokenData, CreateInviteTokenError, CreateInviteTokenResponse, GetConnectUrlData, GetConnectUrlError, GetConnectUrlResponse, HandleOAuthCallbackData, HandleOAuthCallbackError, HandleOAuthCallbackResponse, ListFacebookPagesData, ListFacebookPagesError, ListFacebookPagesResponse, SelectFacebookPageData, SelectFacebookPageError, SelectFacebookPageResponse, ListGoogleBusinessLocationsData, ListGoogleBusinessLocationsError, ListGoogleBusinessLocationsResponse, SelectGoogleBusinessLocationData, SelectGoogleBusinessLocationError, SelectGoogleBusinessLocationResponse, GetGoogleBusinessReviewsData, GetGoogleBusinessReviewsError, GetGoogleBusinessReviewsResponse, GetGoogleBusinessFoodMenusData, GetGoogleBusinessFoodMenusError, GetGoogleBusinessFoodMenusResponse, UpdateGoogleBusinessFoodMenusData, UpdateGoogleBusinessFoodMenusError, UpdateGoogleBusinessFoodMenusResponse, GetGoogleBusinessLocationDetailsData, GetGoogleBusinessLocationDetailsError, GetGoogleBusinessLocationDetailsResponse, UpdateGoogleBusinessLocationDetailsData, UpdateGoogleBusinessLocationDetailsError, UpdateGoogleBusinessLocationDetailsResponse, ListGoogleBusinessMediaData, ListGoogleBusinessMediaError, ListGoogleBusinessMediaResponse, CreateGoogleBusinessMediaData, CreateGoogleBusinessMediaError, CreateGoogleBusinessMediaResponse, DeleteGoogleBusinessMediaData, DeleteGoogleBusinessMediaError, DeleteGoogleBusinessMediaResponse, GetGoogleBusinessAttributesData, GetGoogleBusinessAttributesError, GetGoogleBusinessAttributesResponse, UpdateGoogleBusinessAttributesData, UpdateGoogleBusinessAttributesError, UpdateGoogleBusinessAttributesResponse, ListGoogleBusinessPlaceActionsData, ListGoogleBusinessPlaceActionsError, ListGoogleBusinessPlaceActionsResponse, CreateGoogleBusinessPlaceActionData, CreateGoogleBusinessPlaceActionError, CreateGoogleBusinessPlaceActionResponse, DeleteGoogleBusinessPlaceActionData, DeleteGoogleBusinessPlaceActionError, DeleteGoogleBusinessPlaceActionResponse, GetPendingOAuthDataData, GetPendingOAuthDataError, GetPendingOAuthDataResponse, ListLinkedInOrganizationsData, ListLinkedInOrganizationsError, ListLinkedInOrganizationsResponse, SelectLinkedInOrganizationData, SelectLinkedInOrganizationError, SelectLinkedInOrganizationResponse, ListPinterestBoardsForSelectionData, ListPinterestBoardsForSelectionError, ListPinterestBoardsForSelectionResponse, SelectPinterestBoardData, SelectPinterestBoardError, SelectPinterestBoardResponse, ListSnapchatProfilesData, ListSnapchatProfilesError, ListSnapchatProfilesResponse, SelectSnapchatProfileData, SelectSnapchatProfileError, SelectSnapchatProfileResponse, ConnectBlueskyCredentialsData, ConnectBlueskyCredentialsError, ConnectBlueskyCredentialsResponse, GetTelegramConnectStatusData, GetTelegramConnectStatusError, GetTelegramConnectStatusResponse, InitiateTelegramConnectData, InitiateTelegramConnectError, InitiateTelegramConnectResponse, CompleteTelegramConnectData, CompleteTelegramConnectError, CompleteTelegramConnectResponse, GetFacebookPagesData, GetFacebookPagesError, GetFacebookPagesResponse, UpdateFacebookPageData, UpdateFacebookPageError, UpdateFacebookPageResponse, GetLinkedInOrganizationsData, GetLinkedInOrganizationsError, GetLinkedInOrganizationsResponse, GetLinkedInAggregateAnalyticsData, GetLinkedInAggregateAnalyticsError, GetLinkedInAggregateAnalyticsResponse, GetLinkedInPostAnalyticsData, GetLinkedInPostAnalyticsError, GetLinkedInPostAnalyticsResponse, UpdateLinkedInOrganizationData, UpdateLinkedInOrganizationError, UpdateLinkedInOrganizationResponse, GetLinkedInMentionsData, GetLinkedInMentionsError, GetLinkedInMentionsResponse, GetPinterestBoardsData, GetPinterestBoardsError, GetPinterestBoardsResponse, UpdatePinterestBoardsData, UpdatePinterestBoardsError, UpdatePinterestBoardsResponse, GetGmbLocationsData, GetGmbLocationsError, GetGmbLocationsResponse, UpdateGmbLocationData, UpdateGmbLocationError, UpdateGmbLocationResponse, GetRedditSubredditsData, GetRedditSubredditsError, GetRedditSubredditsResponse, UpdateRedditSubredditsData, UpdateRedditSubredditsError, UpdateRedditSubredditsResponse, GetRedditFlairsData, GetRedditFlairsError, GetRedditFlairsResponse, ListQueueSlotsData, ListQueueSlotsError, ListQueueSlotsResponse, CreateQueueSlotData, CreateQueueSlotError, CreateQueueSlotResponse, UpdateQueueSlotData, UpdateQueueSlotError, UpdateQueueSlotResponse, DeleteQueueSlotData, DeleteQueueSlotError, DeleteQueueSlotResponse, PreviewQueueData, PreviewQueueError, PreviewQueueResponse, GetNextQueueSlotData, GetNextQueueSlotError, GetNextQueueSlotResponse, GetWebhookSettingsError, GetWebhookSettingsResponse, CreateWebhookSettingsData, CreateWebhookSettingsError, CreateWebhookSettingsResponse, UpdateWebhookSettingsData, UpdateWebhookSettingsError, UpdateWebhookSettingsResponse, DeleteWebhookSettingsData, DeleteWebhookSettingsError, DeleteWebhookSettingsResponse, TestWebhookData, TestWebhookError, TestWebhookResponse, GetWebhookLogsData, GetWebhookLogsError, GetWebhookLogsResponse, ListLogsData, ListLogsError, ListLogsResponse, GetLogData, GetLogError, GetLogResponse, ListPostsLogsData, ListPostsLogsError, ListPostsLogsResponse, ListConnectionLogsData, ListConnectionLogsError, ListConnectionLogsResponse, GetPostLogsData, GetPostLogsError, GetPostLogsResponse, ListInboxConversationsData, ListInboxConversationsError, ListInboxConversationsResponse, GetInboxConversationData, GetInboxConversationError, GetInboxConversationResponse, UpdateInboxConversationData, UpdateInboxConversationError, UpdateInboxConversationResponse, GetInboxConversationMessagesData, GetInboxConversationMessagesError, GetInboxConversationMessagesResponse, SendInboxMessageData, SendInboxMessageError, SendInboxMessageResponse, EditInboxMessageData, EditInboxMessageError, EditInboxMessageResponse, GetMessengerMenuData, GetMessengerMenuError, GetMessengerMenuResponse, SetMessengerMenuData, SetMessengerMenuError, SetMessengerMenuResponse, DeleteMessengerMenuData, DeleteMessengerMenuError, DeleteMessengerMenuResponse, GetInstagramIceBreakersData, GetInstagramIceBreakersError, GetInstagramIceBreakersResponse, SetInstagramIceBreakersData, SetInstagramIceBreakersError, SetInstagramIceBreakersResponse, DeleteInstagramIceBreakersData, DeleteInstagramIceBreakersError, DeleteInstagramIceBreakersResponse, GetTelegramCommandsData, GetTelegramCommandsError, GetTelegramCommandsResponse, SetTelegramCommandsData, SetTelegramCommandsError, SetTelegramCommandsResponse, DeleteTelegramCommandsData, DeleteTelegramCommandsError, DeleteTelegramCommandsResponse, ListInboxCommentsData, ListInboxCommentsError, ListInboxCommentsResponse, GetInboxPostCommentsData, GetInboxPostCommentsError, GetInboxPostCommentsResponse, ReplyToInboxPostData, ReplyToInboxPostError, ReplyToInboxPostResponse, DeleteInboxCommentData, DeleteInboxCommentError, DeleteInboxCommentResponse, HideInboxCommentData, HideInboxCommentError, HideInboxCommentResponse, UnhideInboxCommentData, UnhideInboxCommentError, UnhideInboxCommentResponse, LikeInboxCommentData, LikeInboxCommentError, LikeInboxCommentResponse, UnlikeInboxCommentData, UnlikeInboxCommentError, UnlikeInboxCommentResponse, SendPrivateReplyToCommentData, SendPrivateReplyToCommentError, SendPrivateReplyToCommentResponse, ListInboxReviewsData, ListInboxReviewsError, ListInboxReviewsResponse, ReplyToInboxReviewData, ReplyToInboxReviewError, ReplyToInboxReviewResponse, DeleteInboxReviewReplyData, DeleteInboxReviewReplyError, DeleteInboxReviewReplyResponse } from './types.gen';

export const client = createClient(createConfig());

/**
 * Download YouTube video
 * Download YouTube videos or audio. Returns available formats or direct download URL.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadYouTubeVideo = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadYouTubeVideoData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadYouTubeVideoResponse, DownloadYouTubeVideoError, ThrowOnError>({
        ...options,
        url: '/v1/tools/youtube/download'
    });
};

/**
 * Get YouTube transcript
 * Extract transcript/captions from a YouTube video.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const getYouTubeTranscript = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetYouTubeTranscriptData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetYouTubeTranscriptResponse, GetYouTubeTranscriptError, ThrowOnError>({
        ...options,
        url: '/v1/tools/youtube/transcript'
    });
};

/**
 * Download Instagram media
 * Download Instagram reels, posts, or photos.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadInstagramMedia = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadInstagramMediaData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadInstagramMediaResponse, DownloadInstagramMediaError, ThrowOnError>({
        ...options,
        url: '/v1/tools/instagram/download'
    });
};

/**
 * Check Instagram hashtag bans
 * Check if Instagram hashtags are banned, restricted, or safe to use.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const checkInstagramHashtags = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CheckInstagramHashtagsData, ThrowOnError>) => {
    return (options?.client ?? client).post<CheckInstagramHashtagsResponse, CheckInstagramHashtagsError, ThrowOnError>({
        ...options,
        url: '/v1/tools/instagram/hashtag-checker'
    });
};

/**
 * Download TikTok video
 * Download TikTok videos with or without watermark.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadTikTokVideo = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadTikTokVideoData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadTikTokVideoResponse, DownloadTikTokVideoError, ThrowOnError>({
        ...options,
        url: '/v1/tools/tiktok/download'
    });
};

/**
 * Download Twitter/X media
 * Download videos from Twitter/X posts.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadTwitterMedia = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadTwitterMediaData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadTwitterMediaResponse, DownloadTwitterMediaError, ThrowOnError>({
        ...options,
        url: '/v1/tools/twitter/download'
    });
};

/**
 * Download Facebook video
 * Download videos and reels from Facebook.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadFacebookVideo = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadFacebookVideoData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadFacebookVideoResponse, DownloadFacebookVideoError, ThrowOnError>({
        ...options,
        url: '/v1/tools/facebook/download'
    });
};

/**
 * Download LinkedIn video
 * Download videos from LinkedIn posts.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadLinkedInVideo = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadLinkedInVideoData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadLinkedInVideoResponse, DownloadLinkedInVideoError, ThrowOnError>({
        ...options,
        url: '/v1/tools/linkedin/download'
    });
};

/**
 * Download Bluesky media
 * Download videos from Bluesky posts.
 *
 * **Rate Limits:** Build (50/day), Accelerate (500/day), Unlimited (unlimited)
 *
 */
export const downloadBlueskyMedia = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DownloadBlueskyMediaData, ThrowOnError>) => {
    return (options?.client ?? client).get<DownloadBlueskyMediaResponse, DownloadBlueskyMediaError, ThrowOnError>({
        ...options,
        url: '/v1/tools/bluesky/download'
    });
};

/**
 * Get post analytics
 * Returns analytics for posts. With `postId`, returns a single post's analytics. Without it, returns a paginated list with overview stats.
 *
 * **Post ID types:** This endpoint returns External Post IDs by default. The `postId` parameter accepts both Late Post IDs (from `POST /v1/posts`) and External Post IDs. Late Post IDs are automatically resolved to External Post analytics. Use `latePostId` in responses to link analytics back to your original Late post, or `platformPostUrl` as a stable identifier.
 *
 * **List response:** Use `isExternal` to identify post origin. `isExternal: true` means synced from platform, `isExternal: false` means queried by Late post ID.
 *
 * For follower stats, use `/v1/accounts/follower-stats` instead.
 *
 * **Platform notes:**
 * - LinkedIn personal accounts: per-post analytics only for posts published through Late (API restriction).
 * - Telegram: analytics not available (Bot API limitation).
 *
 * **Data freshness:** Cached and refreshed at most once per hour. Stale caches trigger a background refresh.
 *
 */
export const getAnalytics = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<GetAnalyticsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAnalyticsResponse, GetAnalyticsError, ThrowOnError>({
        ...options,
        url: '/v1/analytics'
    });
};

/**
 * Get YouTube daily views
 * Returns historical daily view counts for a specific YouTube video.
 * Uses YouTube Analytics API v2 to fetch daily breakdowns including views,
 * watch time, and subscriber changes.
 *
 * **Required Scope:** This endpoint requires the `yt-analytics.readonly` OAuth scope.
 * Existing YouTube accounts may need to re-authorize to grant this permission.
 * If the scope is missing, the response will include a `reauthorizeUrl`.
 *
 * **Data Latency:** YouTube Analytics data has a 2-3 day delay. The `endDate`
 * is automatically capped to 3 days ago.
 *
 * **Date Range:** Maximum 90 days of historical data available. Defaults to last 30 days.
 *
 */
export const getYouTubeDailyViews = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetYouTubeDailyViewsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetYouTubeDailyViewsResponse, GetYouTubeDailyViewsError, ThrowOnError>({
        ...options,
        url: '/v1/analytics/youtube/daily-views'
    });
};

/**
 * List groups
 */
export const listAccountGroups = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<unknown, ThrowOnError>) => {
    return (options?.client ?? client).get<ListAccountGroupsResponse, ListAccountGroupsError, ThrowOnError>({
        ...options,
        url: '/v1/account-groups'
    });
};

/**
 * Create group
 */
export const createAccountGroup = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateAccountGroupData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateAccountGroupResponse, CreateAccountGroupError, ThrowOnError>({
        ...options,
        url: '/v1/account-groups'
    });
};

/**
 * Update group
 */
export const updateAccountGroup = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateAccountGroupData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateAccountGroupResponse, UpdateAccountGroupError, ThrowOnError>({
        ...options,
        url: '/v1/account-groups/{groupId}'
    });
};

/**
 * Delete group
 */
export const deleteAccountGroup = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteAccountGroupData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteAccountGroupResponse, DeleteAccountGroupError, ThrowOnError>({
        ...options,
        url: '/v1/account-groups/{groupId}'
    });
};

/**
 * Get presigned upload URL
 * Get a presigned URL to upload files directly to cloud storage. Supports files up to 5GB.
 *
 * **How it works:**
 * 1. Call this endpoint with the filename and content type
 * 2. Receive an `uploadUrl` (presigned) and `publicUrl`
 * 3. PUT your file directly to the `uploadUrl`
 * 4. Use the `publicUrl` in your posts
 *
 */
export const getMediaPresignedUrl = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetMediaPresignedUrlData, ThrowOnError>) => {
    return (options?.client ?? client).post<GetMediaPresignedUrlResponse, GetMediaPresignedUrlError, ThrowOnError>({
        ...options,
        url: '/v1/media/presign'
    });
};

/**
 * Search posts
 */
export const searchReddit = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SearchRedditData, ThrowOnError>) => {
    return (options?.client ?? client).get<SearchRedditResponse, SearchRedditError, ThrowOnError>({
        ...options,
        url: '/v1/reddit/search'
    });
};

/**
 * Get subreddit feed
 */
export const getRedditFeed = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetRedditFeedData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetRedditFeedResponse, GetRedditFeedError, ThrowOnError>({
        ...options,
        url: '/v1/reddit/feed'
    });
};

/**
 * Get plan and usage stats
 */
export const getUsageStats = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<unknown, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUsageStatsResponse, GetUsageStatsError, ThrowOnError>({
        ...options,
        url: '/v1/usage-stats'
    });
};

/**
 * List posts
 * **Getting Post URLs:**
 * For published posts, each platform entry includes `platformPostUrl` with the public URL.
 * Use `status=published` filter to fetch only published posts with their URLs.
 *
 * Notes and constraints by platform when interpreting the response:
 * - YouTube: posts always include at least one video in mediaItems.
 * - Instagram/TikTok: posts always include media; drafts may omit media until finalized in client.
 * - TikTok: mediaItems will not mix photos and videos in the same post.
 *
 */
export const listPosts = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListPostsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListPostsResponse, ListPostsError, ThrowOnError>({
        ...options,
        url: '/v1/posts'
    });
};

/**
 * Create post
 * **Getting Post URLs:**
 * - Immediate posts (`publishNow: true`): response includes `platformPostUrl` in `post.platforms[]`.
 * - Scheduled posts: fetch via `GET /v1/posts/{postId}` after publish time for `platformPostUrl`.
 *
 * **Content requirements:**
 * - `content` is optional when media is attached, all platforms have `customContent`, or posting to YouTube only.
 * - Text-only posts require `content`. Stories ignore captions.
 *
 * **Platform constraints:**
 * - YouTube: video required, optional thumbnail via `MediaItem.thumbnail`
 * - Instagram/TikTok: media required; TikTok cannot mix videos and images
 * - Instagram carousels: up to 10 items; Threads carousels: up to 10 images only
 * - Facebook Stories: single image or video, set `contentType: 'story'`
 * - LinkedIn: up to 20 images or a single PDF (max 100MB)
 * - Pinterest: single image or video, `boardId` required
 * - Bluesky: up to 4 images, auto-recompressed to ~1MB
 * - Snapchat: single image or video, set `contentType` in platformSpecificData
 *
 */
export const createPost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreatePostData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreatePostResponse, CreatePostError, ThrowOnError>({
        ...options,
        url: '/v1/posts'
    });
};

/**
 * Get post
 * Fetch a single post by ID. For published posts, this returns `platformPostUrl`
 * for each platform - useful for retrieving post URLs after scheduled posts publish.
 *
 */
export const getPost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetPostData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPostResponse, GetPostError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}'
    });
};

/**
 * Update post
 * Update an existing post. Only draft, scheduled, failed, and partial posts can be edited.
 * Published, publishing, and cancelled posts cannot be modified.
 *
 */
export const updatePost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdatePostData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdatePostResponse, UpdatePostError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}'
    });
};

/**
 * Delete post
 * Delete a draft or scheduled post from Late. Only posts that have not been published can be deleted.
 * To remove a published post from a social media platform, use the [Unpublish endpoint](#tag/Posts/operation/unpublishPost) instead.
 * When deleting a scheduled or draft post that consumed upload quota, the quota will be automatically refunded.
 *
 */
export const deletePost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeletePostData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeletePostResponse, DeletePostError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}'
    });
};

/**
 * Bulk upload from CSV
 */
export const bulkUploadPosts = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<BulkUploadPostsData, ThrowOnError>) => {
    return (options?.client ?? client).post<BulkUploadPostsResponse, BulkUploadPostsError, ThrowOnError>({
        ...options,
        ...formDataBodySerializer,
        headers: {
            'Content-Type': null,
            ...options?.headers
        },
        url: '/v1/posts/bulk-upload'
    });
};

/**
 * Retry failed post
 */
export const retryPost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<RetryPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<RetryPostResponse, RetryPostError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}/retry'
    });
};

/**
 * Unpublish post
 * Permanently deletes a published post from the specified social media platform.
 * The post record in Late is kept but its platform status is updated to "cancelled".
 * This does not delete the post from Late, only from the platform.
 *
 * **Supported platforms:** Threads, Facebook, Twitter/X, LinkedIn, YouTube, Pinterest, Reddit, Bluesky, Google Business, Telegram.
 *
 * **Not supported:**
 * - **Instagram:** No deletion API available. Posts must be deleted manually.
 * - **TikTok:** No deletion API available. Posts must be deleted manually.
 * - **Snapchat:** No deletion API available. Posts must be deleted manually.
 *
 * **Platform notes:**
 * - **Threaded posts (Twitter, Threads, Bluesky):** If the post was published as a thread, all items in the thread are deleted (not just the first one). Posts published before this feature was added will only have the first item deleted.
 * - **Telegram:** Messages older than 48 hours may fail to delete (Telegram Bot API limitation).
 * - **YouTube:** This permanently deletes the video from YouTube.
 *
 */
export const unpublishPost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UnpublishPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<UnpublishPostResponse, UnpublishPostError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}/unpublish'
    });
};

/**
 * List users
 */
export const listUsers = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<unknown, ThrowOnError>) => {
    return (options?.client ?? client).get<ListUsersResponse, ListUsersError, ThrowOnError>({
        ...options,
        url: '/v1/users'
    });
};

/**
 * Get user
 */
export const getUser = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetUserData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetUserResponse, GetUserError, ThrowOnError>({
        ...options,
        url: '/v1/users/{userId}'
    });
};

/**
 * List profiles
 * Returns profiles within the user's plan limit. Profiles are sorted by creation date (oldest first).
 * Use `includeOverLimit=true` to include profiles that exceed the plan limit (for management/deletion purposes).
 *
 */
export const listProfiles = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListProfilesData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListProfilesResponse, ListProfilesError, ThrowOnError>({
        ...options,
        url: '/v1/profiles'
    });
};

/**
 * Create profile
 */
export const createProfile = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateProfileData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateProfileResponse, CreateProfileError, ThrowOnError>({
        ...options,
        url: '/v1/profiles'
    });
};

/**
 * Get profile
 */
export const getProfile = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetProfileData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetProfileResponse, GetProfileError, ThrowOnError>({
        ...options,
        url: '/v1/profiles/{profileId}'
    });
};

/**
 * Update profile
 */
export const updateProfile = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateProfileData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateProfileResponse, UpdateProfileError, ThrowOnError>({
        ...options,
        url: '/v1/profiles/{profileId}'
    });
};

/**
 * Delete profile
 */
export const deleteProfile = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteProfileData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteProfileResponse, DeleteProfileError, ThrowOnError>({
        ...options,
        url: '/v1/profiles/{profileId}'
    });
};

/**
 * List accounts
 * Returns list of connected social accounts.
 * By default, only returns accounts from profiles within the user's plan limit.
 * Follower count data (followersCount, followersLastUpdated) is only included if user has analytics add-on.
 *
 */
export const listAccounts = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListAccountsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListAccountsResponse, ListAccountsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts'
    });
};

/**
 * Get follower stats
 * Returns follower count history and growth metrics for connected social accounts.
 * **Requires analytics add-on subscription.**
 *
 * **Data Freshness:** Follower counts are automatically refreshed once per day.
 *
 */
export const getFollowerStats = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<GetFollowerStatsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetFollowerStatsResponse, GetFollowerStatsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/follower-stats'
    });
};

/**
 * Update account
 */
export const updateAccount = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateAccountData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateAccountResponse, UpdateAccountError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}'
    });
};

/**
 * Disconnect account
 */
export const deleteAccount = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteAccountData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteAccountResponse, DeleteAccountError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}'
    });
};

/**
 * Check accounts health
 * Returns the health status of all connected social accounts, including token validity,
 * permissions status, and any issues that need attention. Useful for monitoring account
 * connections and identifying accounts that need reconnection.
 *
 */
export const getAllAccountsHealth = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<GetAllAccountsHealthData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAllAccountsHealthResponse, GetAllAccountsHealthError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/health'
    });
};

/**
 * Check account health
 * Returns detailed health information for a specific social account, including token status,
 * granted permissions, missing permissions, and actionable recommendations.
 *
 */
export const getAccountHealth = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetAccountHealthData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetAccountHealthResponse, GetAccountHealthError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/health'
    });
};

/**
 * List keys
 */
export const listApiKeys = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<unknown, ThrowOnError>) => {
    return (options?.client ?? client).get<ListApiKeysResponse, ListApiKeysError, ThrowOnError>({
        ...options,
        url: '/v1/api-keys'
    });
};

/**
 * Create key
 */
export const createApiKey = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateApiKeyData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateApiKeyResponse, CreateApiKeyError, ThrowOnError>({
        ...options,
        url: '/v1/api-keys'
    });
};

/**
 * Delete key
 */
export const deleteApiKey = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteApiKeyData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteApiKeyResponse, DeleteApiKeyError, ThrowOnError>({
        ...options,
        url: '/v1/api-keys/{keyId}'
    });
};

/**
 * Create invite token
 * Generate a secure invite link to grant team members access to your profiles.
 * Invites expire after 7 days and are single-use.
 *
 */
export const createInviteToken = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateInviteTokenData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateInviteTokenResponse, CreateInviteTokenError, ThrowOnError>({
        ...options,
        url: '/v1/invite/tokens'
    });
};

/**
 * Get OAuth connect URL
 * Initiate an OAuth connection flow for any supported social media platform.
 *
 * **Standard Flow (Hosted UI):**
 * 1. Call this endpoint with your API key and `redirect_url` (optional)
 * 2. Redirect your user to the returned `authUrl`
 * 3. After OAuth, Late hosts the page/account selection UI
 * 4. Once the user picks, Late saves the connection and redirects to your `redirect_url` (if provided)
 *
 * **Headless Mode (Facebook, LinkedIn, Pinterest, Google Business, Snapchat):**
 * Build your own branded selection UI while Late handles OAuth. Add `&headless=true` to this endpoint:
 *
 * `GET /v1/connect/{platform}?profileId=PROFILE_ID&redirect_url=https://yourapp.com/callback&headless=true`
 *
 * After OAuth, the user is redirected to your `redirect_url` with OAuth data including `profileId`, `tempToken`, `userProfile`, `connect_token`, `platform`, and a `step` parameter indicating what selection is needed.
 *
 * **Facebook example:**
 * 1. Redirect params include `step=select_page`
 * 2. Use `GET /v1/connect/facebook/select-page` to fetch pages
 * 3. Use `POST /v1/connect/facebook/select-page` to save the selected page
 *
 * LinkedIn, Pinterest, Google Business, and Snapchat follow the same pattern with their respective selection endpoints. LinkedIn uses `pendingDataToken` instead of `tempToken` in redirect params; call `GET /v1/connect/pending-data?token=TOKEN` to retrieve the OAuth data (one-time use, expires in 10 minutes).
 *
 */
export const getConnectUrl = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetConnectUrlData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetConnectUrlResponse, GetConnectUrlError, ThrowOnError>({
        ...options,
        url: '/v1/connect/{platform}'
    });
};

/**
 * Complete OAuth callback
 */
export const handleOAuthCallback = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<HandleOAuthCallbackData, ThrowOnError>) => {
    return (options?.client ?? client).post<HandleOAuthCallbackResponse, HandleOAuthCallbackError, ThrowOnError>({
        ...options,
        url: '/v1/connect/{platform}'
    });
};

/**
 * List Facebook pages
 * **Headless Mode for Custom UI**
 *
 * After initiating Facebook OAuth via `/v1/connect/facebook`, you'll be redirected to
 * `/connect/facebook/select-page` with query params including `tempToken` and `userProfile`.
 *
 * For a **headless/whitelabeled flow**, extract these params from the URL and call this
 * endpoint to retrieve the list of Facebook Pages the user can manage. Then build your
 * own UI to let users select a page.
 *
 * **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key
 * (rather than a browser session).
 *
 */
export const listFacebookPages = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListFacebookPagesData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListFacebookPagesResponse, ListFacebookPagesError, ThrowOnError>({
        ...options,
        url: '/v1/connect/facebook/select-page'
    });
};

/**
 * Select Facebook page
 * **Complete the Headless Flow**
 *
 * After displaying your custom UI with the list of pages from the GET endpoint, call this
 * endpoint to finalize the connection with the user's selected page.
 *
 * The `userProfile` should be the decoded JSON object from the `userProfile` query param
 * in the OAuth callback redirect URL.
 *
 * **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key.
 *
 */
export const selectFacebookPage = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SelectFacebookPageData, ThrowOnError>) => {
    return (options?.client ?? client).post<SelectFacebookPageResponse, SelectFacebookPageError, ThrowOnError>({
        ...options,
        url: '/v1/connect/facebook/select-page'
    });
};

/**
 * List Google Business locations
 * **Headless Mode for Custom UI**
 *
 * After initiating Google Business OAuth via `/v1/connect/googlebusiness?headless=true`, you'll be redirected
 * to your `redirect_url` with query params including `tempToken` and `userProfile`.
 *
 * For a **headless/whitelabeled flow**, extract these params from the URL and call this
 * endpoint to retrieve the list of Google Business locations the user can manage. Then build your
 * own UI to let users select a location.
 *
 * **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key
 * (rather than a browser session).
 *
 */
export const listGoogleBusinessLocations = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListGoogleBusinessLocationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListGoogleBusinessLocationsResponse, ListGoogleBusinessLocationsError, ThrowOnError>({
        ...options,
        url: '/v1/connect/googlebusiness/locations'
    });
};

/**
 * Select Google Business location
 * **Complete the Headless Flow**
 *
 * After displaying your custom UI with the list of locations from the GET `/v1/connect/googlebusiness/locations`
 * endpoint, call this endpoint to finalize the connection with the user's selected location.
 *
 * The `userProfile` should be the decoded JSON object from the `userProfile` query param
 * in the OAuth callback redirect URL. It contains important token information (including refresh token).
 *
 * **Note:** Use the `X-Connect-Token` header if you initiated the connection via API key.
 *
 */
export const selectGoogleBusinessLocation = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SelectGoogleBusinessLocationData, ThrowOnError>) => {
    return (options?.client ?? client).post<SelectGoogleBusinessLocationResponse, SelectGoogleBusinessLocationError, ThrowOnError>({
        ...options,
        url: '/v1/connect/googlebusiness/select-location'
    });
};

/**
 * Get reviews
 * Fetches reviews for a connected Google Business Profile account.
 *
 * Returns all reviews for the business location, including:
 * - Reviewer information (name, profile photo)
 * - Star rating (1-5)
 * - Review comment/text
 * - Business owner's reply (if any)
 * - Review timestamps
 *
 * Use pagination via `nextPageToken` to fetch all reviews for locations with many reviews.
 *
 */
export const getGoogleBusinessReviews = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetGoogleBusinessReviewsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGoogleBusinessReviewsResponse, GetGoogleBusinessReviewsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-reviews'
    });
};

/**
 * Get food menus
 * Fetches food menus for a connected Google Business Profile location.
 *
 * Returns the full menu structure including:
 * - Menu names and descriptions
 * - Sections (e.g. Appetizers, Entrees, Drinks)
 * - Items with labels, pricing, dietary info, and allergens
 * - Item options/variants
 *
 * Only available for locations with food menu support (restaurants, cafes, etc.).
 *
 */
export const getGoogleBusinessFoodMenus = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetGoogleBusinessFoodMenusData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGoogleBusinessFoodMenusResponse, GetGoogleBusinessFoodMenusError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-food-menus'
    });
};

/**
 * Update food menus
 * Updates the food menus for a connected Google Business Profile location.
 *
 * Send the full menus array. Use `updateMask` for partial updates (e.g. `"menus"` to only update the menus field).
 *
 * Each menu can contain sections, and each section can contain items with pricing, dietary restrictions, allergens, and more.
 *
 */
export const updateGoogleBusinessFoodMenus = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateGoogleBusinessFoodMenusData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateGoogleBusinessFoodMenusResponse, UpdateGoogleBusinessFoodMenusError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-food-menus'
    });
};

/**
 * Get location details
 * Fetches detailed location information including opening hours, special hours,
 * business description, phone numbers, website, categories, and more.
 *
 * Use the `readMask` query parameter to request specific fields.
 *
 */
export const getGoogleBusinessLocationDetails = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetGoogleBusinessLocationDetailsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGoogleBusinessLocationDetailsResponse, GetGoogleBusinessLocationDetailsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-location-details'
    });
};

/**
 * Update location details
 * Updates location details such as opening hours, special hours, business description, phone, and website.
 *
 * The `updateMask` field is required and specifies which fields to update.
 *
 * Common update masks:
 * - `regularHours` - Update opening hours
 * - `specialHours` - Update holiday/special hours
 * - `profile.description` - Update business description
 * - `websiteUri` - Update website URL
 * - `phoneNumbers` - Update phone numbers
 * - `regularHours,specialHours` - Update both at once
 *
 */
export const updateGoogleBusinessLocationDetails = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateGoogleBusinessLocationDetailsData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateGoogleBusinessLocationDetailsResponse, UpdateGoogleBusinessLocationDetailsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-location-details'
    });
};

/**
 * List media
 * Lists media items (photos) for a Google Business Profile location.
 * Returns photo URLs, descriptions, categories, and metadata.
 *
 */
export const listGoogleBusinessMedia = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListGoogleBusinessMediaData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListGoogleBusinessMediaResponse, ListGoogleBusinessMediaError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-media'
    });
};

/**
 * Upload photo
 * Creates a media item (photo) for a location from a publicly accessible URL.
 *
 * Categories determine where the photo appears:
 * - `COVER` - Cover photo
 * - `PROFILE` - Profile photo
 * - `LOGO` - Business logo
 * - `EXTERIOR` - Exterior shots
 * - `INTERIOR` - Interior shots
 * - `FOOD_AND_DRINK` - Food and drink photos
 * - `MENU` - Menu photos
 * - `PRODUCT` - Product photos
 * - `TEAMS` - Team/staff photos
 * - `ADDITIONAL` - Other photos
 *
 */
export const createGoogleBusinessMedia = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateGoogleBusinessMediaData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateGoogleBusinessMediaResponse, CreateGoogleBusinessMediaError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-media'
    });
};

/**
 * Delete photo
 */
export const deleteGoogleBusinessMedia = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteGoogleBusinessMediaData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteGoogleBusinessMediaResponse, DeleteGoogleBusinessMediaError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-media'
    });
};

/**
 * Get attributes
 * Fetches location attributes such as amenities, services, and accessibility features.
 *
 * Common attributes for restaurants include:
 * - Dining options: has_dine_in, has_takeout, has_delivery
 * - Amenities: has_outdoor_seating, has_wifi, has_parking
 * - Accessibility: has_wheelchair_accessible_entrance
 * - Payments: pay_credit_card_types_accepted
 *
 * Available attributes vary by business category.
 *
 */
export const getGoogleBusinessAttributes = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetGoogleBusinessAttributesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGoogleBusinessAttributesResponse, GetGoogleBusinessAttributesError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-attributes'
    });
};

/**
 * Update attributes
 * Updates location attributes (amenities, services, etc.).
 *
 * The `attributeMask` specifies which attributes to update (comma-separated).
 *
 */
export const updateGoogleBusinessAttributes = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateGoogleBusinessAttributesData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateGoogleBusinessAttributesResponse, UpdateGoogleBusinessAttributesError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-attributes'
    });
};

/**
 * List action links
 * Lists place action links for a Google Business Profile location.
 *
 * Place actions are the booking, ordering, and reservation buttons that appear on your listing.
 *
 */
export const listGoogleBusinessPlaceActions = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListGoogleBusinessPlaceActionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListGoogleBusinessPlaceActionsResponse, ListGoogleBusinessPlaceActionsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-place-actions'
    });
};

/**
 * Create action link
 * Creates a place action link for a location.
 *
 * Available action types:
 * - `APPOINTMENT` - Booking an appointment
 * - `ONLINE_APPOINTMENT` - Booking an online appointment
 * - `DINING_RESERVATION` - Making a dining reservation (OpenTable, Resy, etc.)
 * - `FOOD_ORDERING` - Ordering food for delivery and/or takeout (DoorDash, Uber Eats, etc.)
 * - `FOOD_DELIVERY` - Ordering food for delivery only
 * - `FOOD_TAKEOUT` - Ordering food for takeout only
 * - `SHOP_ONLINE` - Shopping with delivery and/or pickup
 *
 */
export const createGoogleBusinessPlaceAction = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateGoogleBusinessPlaceActionData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateGoogleBusinessPlaceActionResponse, CreateGoogleBusinessPlaceActionError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-place-actions'
    });
};

/**
 * Delete action link
 */
export const deleteGoogleBusinessPlaceAction = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteGoogleBusinessPlaceActionData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteGoogleBusinessPlaceActionResponse, DeleteGoogleBusinessPlaceActionError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-place-actions'
    });
};

/**
 * Get pending OAuth data
 * **Fetch Pending OAuth Data for Headless Mode**
 *
 * In headless mode, platforms like LinkedIn store OAuth selection data (organizations, pages, etc.)
 * in the database instead of passing it via URL parameters. This prevents URI_TOO_LONG errors
 * when users have many organizations/pages to select from.
 *
 * After OAuth redirect, use the `pendingDataToken` from the URL to fetch the stored data.
 *
 * **Important:**
 * - This endpoint is one-time use: data is deleted after being fetched
 * - Data expires automatically after 10 minutes if not fetched
 * - No authentication required, just the token from the redirect URL
 *
 */
export const getPendingOAuthData = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetPendingOAuthDataData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPendingOAuthDataResponse, GetPendingOAuthDataError, ThrowOnError>({
        ...options,
        url: '/v1/connect/pending-data'
    });
};

/**
 * List LinkedIn orgs
 * **Fetch Full Organization Details for Custom UI**
 *
 * After LinkedIn OAuth in headless mode, the redirect URL contains organization data with only
 * `id`, `urn`, and `name` fields (additional details are excluded to prevent URL length issues with many organizations).
 *
 * Use this endpoint to fetch full organization details including logos, vanity names, websites, and more
 * if you want to display them in your custom selection UI.
 *
 * **Note:** This endpoint requires no authentication - just the `tempToken` from the OAuth redirect.
 * Details are fetched directly from LinkedIn's API in parallel for fast response times.
 *
 */
export const listLinkedInOrganizations = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListLinkedInOrganizationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListLinkedInOrganizationsResponse, ListLinkedInOrganizationsError, ThrowOnError>({
        ...options,
        url: '/v1/connect/linkedin/organizations'
    });
};

/**
 * Select LinkedIn org
 * **Complete the LinkedIn Connection Flow**
 *
 * After OAuth, the user is redirected with `organizations` in the URL params (if they have org admin access).
 * The organizations array contains `id`, `urn`, and `name` fields. Use this data to build your UI,
 * then call this endpoint to save the selection.
 *
 * Set `accountType` to `personal` to connect as the user's personal LinkedIn profile, or
 * `organization` to connect as a company page (requires `selectedOrganization` object).
 *
 * **Personal Profile:** To connect a personal LinkedIn account, set `accountType` to `"personal"`
 * and **omit** the `selectedOrganization` field entirely. This is the simplest flow.
 *
 * **Headless Mode:** Use the `X-Connect-Token` header if you initiated the connection via API key.
 *
 */
export const selectLinkedInOrganization = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SelectLinkedInOrganizationData, ThrowOnError>) => {
    return (options?.client ?? client).post<SelectLinkedInOrganizationResponse, SelectLinkedInOrganizationError, ThrowOnError>({
        ...options,
        url: '/v1/connect/linkedin/select-organization'
    });
};

/**
 * List Pinterest boards
 * **Retrieve Pinterest Boards for Selection UI**
 *
 * After initiating Pinterest OAuth via `/v1/connect/pinterest` with `headless=true`, you'll be redirected to
 * your `redirect_url` with query params including `tempToken` and `userProfile`.
 *
 * If you want to build your own fully-branded board selector (instead of Late's hosted UI), call this
 * endpoint to retrieve the list of Pinterest Boards the user can post to. Then build your
 * UI and call `POST /v1/connect/pinterest/select-board` to save the selection.
 *
 * **Authentication:** Use `X-Connect-Token` header with the `connect_token` from the redirect URL.
 *
 */
export const listPinterestBoardsForSelection = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListPinterestBoardsForSelectionData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListPinterestBoardsForSelectionResponse, ListPinterestBoardsForSelectionError, ThrowOnError>({
        ...options,
        url: '/v1/connect/pinterest/select-board'
    });
};

/**
 * Select Pinterest board
 * **Complete the Pinterest Connection Flow**
 *
 * After OAuth, use this endpoint to save the selected board and complete the Pinterest account connection.
 *
 * **Headless Mode:** Use the `X-Connect-Token` header if you initiated the connection via API key.
 *
 */
export const selectPinterestBoard = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SelectPinterestBoardData, ThrowOnError>) => {
    return (options?.client ?? client).post<SelectPinterestBoardResponse, SelectPinterestBoardError, ThrowOnError>({
        ...options,
        url: '/v1/connect/pinterest/select-board'
    });
};

/**
 * List Snapchat profiles
 * **Headless Mode for Custom UI**
 *
 * After initiating Snapchat OAuth via `/v1/connect/snapchat?headless=true`, you'll be redirected to
 * your `redirect_url` with query params including `tempToken`, `userProfile`, and `publicProfiles`.
 *
 * If you want to build your own fully-branded profile selector (instead of Late's hosted UI), call this
 * endpoint to retrieve the list of Snapchat Public Profiles the user can post to. Then build your
 * UI and call `POST /v1/connect/snapchat/select-profile` to save the selection.
 *
 * **Authentication:** Use `X-Connect-Token` header with the `connect_token` from the redirect URL.
 *
 */
export const listSnapchatProfiles = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListSnapchatProfilesData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListSnapchatProfilesResponse, ListSnapchatProfilesError, ThrowOnError>({
        ...options,
        url: '/v1/connect/snapchat/select-profile'
    });
};

/**
 * Select Snapchat profile
 * **Complete the Snapchat Connection Flow**
 *
 * After OAuth, use this endpoint to save the selected Public Profile and complete the Snapchat account connection.
 * Snapchat requires a Public Profile to publish Stories, Saved Stories, and Spotlight content.
 *
 * **Headless Mode:** Use the `X-Connect-Token` header if you initiated the connection via API key.
 *
 * After initiating Snapchat OAuth via `/v1/connect/snapchat?headless=true`, you'll be redirected to
 * your `redirect_url` with query params including:
 * - `tempToken` - Temporary access token
 * - `userProfile` - URL-encoded JSON with user info
 * - `publicProfiles` - URL-encoded JSON array of available public profiles
 * - `connect_token` - Short-lived token for API authentication
 * - `platform=snapchat`
 * - `step=select_public_profile`
 *
 * Parse `publicProfiles` to build your custom selector UI, then call this endpoint with the selected profile.
 *
 */
export const selectSnapchatProfile = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SelectSnapchatProfileData, ThrowOnError>) => {
    return (options?.client ?? client).post<SelectSnapchatProfileResponse, SelectSnapchatProfileError, ThrowOnError>({
        ...options,
        url: '/v1/connect/snapchat/select-profile'
    });
};

/**
 * Connect Bluesky account
 * Connect a Bluesky account using identifier (handle or email) and an app password.
 *
 * To get your userId for the state parameter, call `GET /v1/users` - the response includes a `currentUserId` field.
 *
 */
export const connectBlueskyCredentials = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ConnectBlueskyCredentialsData, ThrowOnError>) => {
    return (options?.client ?? client).post<ConnectBlueskyCredentialsResponse, ConnectBlueskyCredentialsError, ThrowOnError>({
        ...options,
        url: '/v1/connect/bluesky/credentials'
    });
};

/**
 * Generate Telegram code
 * Generate a unique access code for connecting a Telegram channel or group.
 *
 * **Connection Flow:**
 * 1. Call this endpoint to get an access code (valid for 15 minutes)
 * 2. Add the bot (@LateScheduleBot or your configured bot) as an administrator in your Telegram channel/group
 * 3. Open a private chat with the bot
 * 4. Send: `{CODE} @yourchannel` (e.g., `LATE-ABC123 @mychannel`)
 * 5. Poll `PATCH /v1/connect/telegram?code={CODE}` to check connection status
 *
 * **Alternative for private channels:** If your channel has no public username, forward any message from the channel to the bot along with the access code.
 *
 */
export const getTelegramConnectStatus = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetTelegramConnectStatusData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetTelegramConnectStatusResponse, GetTelegramConnectStatusError, ThrowOnError>({
        ...options,
        url: '/v1/connect/telegram'
    });
};

/**
 * Connect Telegram directly
 * Connect a Telegram channel/group directly using the chat ID.
 *
 * This is an alternative to the access code flow for power users who know their Telegram chat ID.
 * The bot must already be added as an administrator in the channel/group.
 *
 */
export const initiateTelegramConnect = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<InitiateTelegramConnectData, ThrowOnError>) => {
    return (options?.client ?? client).post<InitiateTelegramConnectResponse, InitiateTelegramConnectError, ThrowOnError>({
        ...options,
        url: '/v1/connect/telegram'
    });
};

/**
 * Check Telegram status
 * Poll this endpoint to check if a Telegram access code has been used to connect a channel/group.
 *
 * **Recommended polling interval:** 3 seconds
 *
 * **Status values:**
 * - `pending`: Code is valid, waiting for user to complete connection
 * - `connected`: Connection successful - channel/group is now linked
 * - `expired`: Code has expired, generate a new one
 *
 */
export const completeTelegramConnect = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CompleteTelegramConnectData, ThrowOnError>) => {
    return (options?.client ?? client).patch<CompleteTelegramConnectResponse, CompleteTelegramConnectError, ThrowOnError>({
        ...options,
        url: '/v1/connect/telegram'
    });
};

/**
 * List Facebook pages
 * Returns all Facebook pages the connected account has access to, including the currently selected page.
 */
export const getFacebookPages = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetFacebookPagesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetFacebookPagesResponse, GetFacebookPagesError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/facebook-page'
    });
};

/**
 * Update Facebook page
 */
export const updateFacebookPage = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateFacebookPageData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateFacebookPageResponse, UpdateFacebookPageError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/facebook-page'
    });
};

/**
 * List LinkedIn orgs
 */
export const getLinkedInOrganizations = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetLinkedInOrganizationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLinkedInOrganizationsResponse, GetLinkedInOrganizationsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/linkedin-organizations'
    });
};

/**
 * Get LinkedIn aggregate stats
 * Returns aggregate analytics across all posts for a LinkedIn personal account. Organization accounts should use `/v1/analytics` instead.
 *
 * **Required scope:** `r_member_postAnalytics`. Missing scope returns 403 with reconnect instructions.
 *
 * **Aggregation:** `TOTAL` (default, lifetime totals) or `DAILY` (time series). Use `startDate`/`endDate` to filter by date range. Note: `MEMBERS_REACHED` is not available with `DAILY` aggregation.
 *
 */
export const getLinkedInAggregateAnalytics = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetLinkedInAggregateAnalyticsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLinkedInAggregateAnalyticsResponse, GetLinkedInAggregateAnalyticsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/linkedin-aggregate-analytics'
    });
};

/**
 * Get LinkedIn post stats
 * Returns analytics for a specific LinkedIn post using its URN.
 * Works for both personal and organization accounts.
 *
 * This is useful for fetching analytics of posts that weren't published through Late,
 * as long as you have the post URN.
 *
 * **For Personal Accounts:**
 * - Uses `memberCreatorPostAnalytics` API + `memberCreatorVideoAnalytics` for video posts
 * - Requires `r_member_postAnalytics` scope
 * - Available metrics: impressions, reach, likes, comments, shares, video views (video posts only)
 * - **Clicks are NOT available** for personal accounts
 *
 * **For Organization Accounts:**
 * - Uses `organizationalEntityShareStatistics` API + `videoAnalytics` for video posts
 * - Requires `r_organization_social` scope
 * - Available metrics: impressions, reach, clicks, likes, comments, shares, video views (video posts only), engagement rate
 *
 */
export const getLinkedInPostAnalytics = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetLinkedInPostAnalyticsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLinkedInPostAnalyticsResponse, GetLinkedInPostAnalyticsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/linkedin-post-analytics'
    });
};

/**
 * Switch LinkedIn account type
 */
export const updateLinkedInOrganization = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateLinkedInOrganizationData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateLinkedInOrganizationResponse, UpdateLinkedInOrganizationError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/linkedin-organization'
    });
};

/**
 * Resolve LinkedIn mention
 * Converts a LinkedIn profile or company URL to a URN for @mentions in posts. Supports person mentions (`linkedin.com/in/username` or just `username`) and organization mentions (`linkedin.com/company/name` or `company/name`).
 *
 * Person mentions require the connected account to have admin access to at least one LinkedIn Organization. Organization mentions work with any account.
 *
 * For person mentions to be clickable, provide the `displayName` parameter matching the exact name on their LinkedIn profile. Organization names are fetched automatically.
 *
 * Use the returned `mentionFormat` value directly in your post content.
 *
 */
export const getLinkedInMentions = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetLinkedInMentionsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLinkedInMentionsResponse, GetLinkedInMentionsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/linkedin-mentions'
    });
};

/**
 * List Pinterest boards
 */
export const getPinterestBoards = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetPinterestBoardsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPinterestBoardsResponse, GetPinterestBoardsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/pinterest-boards'
    });
};

/**
 * Set default Pinterest board
 */
export const updatePinterestBoards = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdatePinterestBoardsData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdatePinterestBoardsResponse, UpdatePinterestBoardsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/pinterest-boards'
    });
};

/**
 * List Google Business locations
 * Returns all Google Business Profile locations the connected account has access to, including the currently selected location.
 */
export const getGmbLocations = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetGmbLocationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetGmbLocationsResponse, GetGmbLocationsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-locations'
    });
};

/**
 * Update Google Business location
 */
export const updateGmbLocation = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateGmbLocationData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateGmbLocationResponse, UpdateGmbLocationError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/gmb-locations'
    });
};

/**
 * List Reddit subreddits
 */
export const getRedditSubreddits = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetRedditSubredditsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetRedditSubredditsResponse, GetRedditSubredditsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/reddit-subreddits'
    });
};

/**
 * Set default subreddit
 */
export const updateRedditSubreddits = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateRedditSubredditsData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateRedditSubredditsResponse, UpdateRedditSubredditsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/reddit-subreddits'
    });
};

/**
 * List subreddit flairs
 */
export const getRedditFlairs = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetRedditFlairsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetRedditFlairsResponse, GetRedditFlairsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/reddit-flairs'
    });
};

/**
 * List schedules
 * Retrieve queue schedules for a profile. Each profile can have multiple queues.
 * - Without `all=true`: Returns the default queue (or specific queue if queueId provided)
 * - With `all=true`: Returns all queues for the profile
 *
 */
export const listQueueSlots = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ListQueueSlotsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListQueueSlotsResponse, ListQueueSlotsError, ThrowOnError>({
        ...options,
        url: '/v1/queue/slots'
    });
};

/**
 * Create schedule
 * Create an additional queue for a profile. The first queue created becomes the default.
 * Subsequent queues are non-default unless explicitly set.
 *
 */
export const createQueueSlot = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateQueueSlotData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateQueueSlotResponse, CreateQueueSlotError, ThrowOnError>({
        ...options,
        url: '/v1/queue/slots'
    });
};

/**
 * Update schedule
 * Create a new queue or update an existing one.
 * - Without queueId: Creates or updates the default queue
 * - With queueId: Updates the specific queue
 * - With setAsDefault=true: Makes this queue the default for the profile
 *
 */
export const updateQueueSlot = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateQueueSlotData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateQueueSlotResponse, UpdateQueueSlotError, ThrowOnError>({
        ...options,
        url: '/v1/queue/slots'
    });
};

/**
 * Delete schedule
 * Delete a queue from a profile. Requires queueId to specify which queue to delete.
 * If deleting the default queue, another queue will be promoted to default.
 *
 */
export const deleteQueueSlot = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteQueueSlotData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteQueueSlotResponse, DeleteQueueSlotError, ThrowOnError>({
        ...options,
        url: '/v1/queue/slots'
    });
};

/**
 * Preview upcoming slots
 */
export const previewQueue = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<PreviewQueueData, ThrowOnError>) => {
    return (options?.client ?? client).get<PreviewQueueResponse, PreviewQueueError, ThrowOnError>({
        ...options,
        url: '/v1/queue/preview'
    });
};

/**
 * Get next available slot
 * Returns the next available queue slot for preview/informational purposes.
 *
 * **Important: To schedule a post to the queue, do NOT use this endpoint's response
 * with `scheduledFor`.** That creates a manual post, not a queue post.
 *
 * Instead, use `POST /v1/posts` with `queuedFromProfile` (and optionally `queueId`).
 * The system will automatically assign the next available slot with proper locking
 * to prevent race conditions.
 *
 * This endpoint is useful for:
 * - Showing users when their next post will go out before they commit
 * - Debugging/verifying queue configuration
 * - Building UI previews
 *
 * If no queueId is specified, uses the profile's default queue.
 *
 */
export const getNextQueueSlot = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetNextQueueSlotData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetNextQueueSlotResponse, GetNextQueueSlotError, ThrowOnError>({
        ...options,
        url: '/v1/queue/next-slot'
    });
};

/**
 * List webhooks
 * Retrieve all configured webhooks for the authenticated user. Supports up to 10 webhooks per user.
 */
export const getWebhookSettings = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<unknown, ThrowOnError>) => {
    return (options?.client ?? client).get<GetWebhookSettingsResponse, GetWebhookSettingsError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/settings'
    });
};

/**
 * Create webhook
 * Create a new webhook configuration. Maximum 10 webhooks per user.
 *
 * **Note:** Webhooks are automatically disabled after 10 consecutive delivery failures.
 *
 */
export const createWebhookSettings = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<CreateWebhookSettingsData, ThrowOnError>) => {
    return (options?.client ?? client).post<CreateWebhookSettingsResponse, CreateWebhookSettingsError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/settings'
    });
};

/**
 * Update webhook
 * Update an existing webhook configuration. All fields except `_id` are optional - only provided fields will be updated.
 *
 * **Note:** Webhooks are automatically disabled after 10 consecutive delivery failures.
 *
 */
export const updateWebhookSettings = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateWebhookSettingsData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateWebhookSettingsResponse, UpdateWebhookSettingsError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/settings'
    });
};

/**
 * Delete webhook
 * Permanently delete a webhook configuration.
 */
export const deleteWebhookSettings = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteWebhookSettingsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteWebhookSettingsResponse, DeleteWebhookSettingsError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/settings'
    });
};

/**
 * Send test webhook
 * Send a test webhook to verify your endpoint is configured correctly.
 * The test payload includes `event: "webhook.test"` to distinguish it from real events.
 *
 */
export const testWebhook = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<TestWebhookData, ThrowOnError>) => {
    return (options?.client ?? client).post<TestWebhookResponse, TestWebhookError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/test'
    });
};

/**
 * Get delivery logs
 * Retrieve webhook delivery history. Logs are automatically deleted after 7 days.
 *
 */
export const getWebhookLogs = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<GetWebhookLogsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetWebhookLogsResponse, GetWebhookLogsError, ThrowOnError>({
        ...options,
        url: '/v1/webhooks/logs'
    });
};

/**
 * @deprecated
 * List publishing logs (deprecated)
 * **Deprecated:** Use `/v1/posts/logs` instead. This endpoint is maintained for backwards compatibility.
 *
 * Retrieve publishing logs for all posts. Logs show detailed information about each
 * publishing attempt including API requests, responses, and timing data.
 *
 * **Filtering:**
 * - Filter by status (success, failed, pending, skipped)
 * - Filter by platform (instagram, twitter, linkedin, etc.)
 * - Filter by action (publish, retry, rate_limit_pause, etc.)
 *
 * **Retention:** Logs are automatically deleted after 7 days.
 *
 */
export const listLogs = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListLogsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListLogsResponse, ListLogsError, ThrowOnError>({
        ...options,
        url: '/v1/logs'
    });
};

/**
 * Get log entry
 * Retrieve detailed information about a specific log entry, including full request
 * and response bodies for debugging.
 *
 */
export const getLog = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetLogData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetLogResponse, GetLogError, ThrowOnError>({
        ...options,
        url: '/v1/logs/{logId}'
    });
};

/**
 * List publishing logs
 * Retrieve publishing logs for all posts. Logs show detailed information about each
 * publishing attempt including API requests, responses, and timing data.
 *
 * **Filtering:**
 * - Filter by status (success, failed, pending, skipped)
 * - Filter by platform (instagram, twitter, linkedin, etc.)
 * - Filter by action (publish, retry, rate_limit_pause, etc.)
 *
 * **Retention:** Logs are automatically deleted after 7 days.
 *
 */
export const listPostsLogs = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListPostsLogsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListPostsLogsResponse, ListPostsLogsError, ThrowOnError>({
        ...options,
        url: '/v1/posts/logs'
    });
};

/**
 * List connection logs
 * Retrieve connection event logs showing account connection and disconnection history.
 * Useful for debugging OAuth issues and tracking account lifecycle.
 *
 * **Event Types:**
 * - `connect_success` - New account connected successfully
 * - `connect_failed` - Connection attempt failed
 * - `disconnect` - Account was disconnected
 * - `reconnect_success` - Existing account reconnected
 * - `reconnect_failed` - Reconnection attempt failed
 *
 * **Retention:** Logs are automatically deleted after 7 days.
 *
 */
export const listConnectionLogs = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListConnectionLogsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListConnectionLogsResponse, ListConnectionLogsError, ThrowOnError>({
        ...options,
        url: '/v1/connections/logs'
    });
};

/**
 * Get post logs
 * Retrieve all publishing logs for a specific post. Shows the complete history
 * of publishing attempts for that post across all platforms.
 *
 */
export const getPostLogs = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetPostLogsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetPostLogsResponse, GetPostLogsError, ThrowOnError>({
        ...options,
        url: '/v1/posts/{postId}/logs'
    });
};

/**
 * List conversations
 * Fetch conversations (DMs) from all connected messaging accounts in a single API call.
 * Supports filtering by profile and platform. Results are aggregated and deduplicated.
 *
 * **Supported platforms:** Facebook, Instagram, Twitter/X, Bluesky, Reddit, Telegram
 *
 */
export const listInboxConversations = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListInboxConversationsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListInboxConversationsResponse, ListInboxConversationsError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations'
    });
};

/**
 * Get conversation
 * Retrieve details and metadata for a specific conversation. Requires accountId query parameter.
 */
export const getInboxConversation = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetInboxConversationData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetInboxConversationResponse, GetInboxConversationError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations/{conversationId}'
    });
};

/**
 * Update conversation status
 * Archive or activate a conversation. Requires accountId in request body.
 */
export const updateInboxConversation = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UpdateInboxConversationData, ThrowOnError>) => {
    return (options?.client ?? client).put<UpdateInboxConversationResponse, UpdateInboxConversationError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations/{conversationId}'
    });
};

/**
 * List messages
 * Fetch messages for a specific conversation. Requires accountId query parameter.
 */
export const getInboxConversationMessages = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetInboxConversationMessagesData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetInboxConversationMessagesResponse, GetInboxConversationMessagesError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations/{conversationId}/messages'
    });
};

/**
 * Send message
 * Send a message in a conversation. Supports text, attachments, quick replies, buttons, carousels, and message tags.
 *
 * **Attachment support by platform:**
 * - Telegram: Images, videos, documents (up to 50MB)
 * - Facebook Messenger: Images, videos, audio, files
 * - Instagram: Images, videos, audio via URL (8MB images, 25MB video/audio)
 * - Twitter/X: Images, videos (requires media upload)
 * - Bluesky/Reddit: Not supported
 *
 * **Interactive messages:** Supports quick replies, buttons, templates, and reply markup. Feature availability varies by platform (Instagram, Facebook, Telegram). Unsupported fields are silently ignored.
 *
 */
export const sendInboxMessage = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SendInboxMessageData, ThrowOnError>) => {
    return (options?.client ?? client).post<SendInboxMessageResponse, SendInboxMessageError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations/{conversationId}/messages'
    });
};

/**
 * Edit message
 * Edit the text and/or reply markup of a previously sent Telegram message.
 * Only supported for Telegram. Returns 400 for other platforms.
 *
 */
export const editInboxMessage = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<EditInboxMessageData, ThrowOnError>) => {
    return (options?.client ?? client).patch<EditInboxMessageResponse, EditInboxMessageError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/conversations/{conversationId}/messages/{messageId}'
    });
};

/**
 * Get Facebook persistent menu
 * Get the persistent menu configuration for a Facebook Messenger account.
 */
export const getMessengerMenu = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetMessengerMenuData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetMessengerMenuResponse, GetMessengerMenuError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/messenger-menu'
    });
};

/**
 * Set Facebook persistent menu
 * Set the persistent menu for a Facebook Messenger account. Max 3 top-level items, max 5 nested items.
 */
export const setMessengerMenu = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SetMessengerMenuData, ThrowOnError>) => {
    return (options?.client ?? client).put<SetMessengerMenuResponse, SetMessengerMenuError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/messenger-menu'
    });
};

/**
 * Delete Facebook persistent menu
 */
export const deleteMessengerMenu = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteMessengerMenuData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteMessengerMenuResponse, DeleteMessengerMenuError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/messenger-menu'
    });
};

/**
 * Get Instagram ice breakers
 * Get the ice breaker configuration for an Instagram account.
 */
export const getInstagramIceBreakers = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetInstagramIceBreakersData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetInstagramIceBreakersResponse, GetInstagramIceBreakersError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/instagram-ice-breakers'
    });
};

/**
 * Set Instagram ice breakers
 * Set ice breakers for an Instagram account. Max 4 ice breakers, question max 80 chars.
 */
export const setInstagramIceBreakers = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SetInstagramIceBreakersData, ThrowOnError>) => {
    return (options?.client ?? client).put<SetInstagramIceBreakersResponse, SetInstagramIceBreakersError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/instagram-ice-breakers'
    });
};

/**
 * Delete Instagram ice breakers
 */
export const deleteInstagramIceBreakers = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteInstagramIceBreakersData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteInstagramIceBreakersResponse, DeleteInstagramIceBreakersError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/instagram-ice-breakers'
    });
};

/**
 * Get Telegram bot commands
 * Get the bot commands configuration for a Telegram account.
 */
export const getTelegramCommands = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetTelegramCommandsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetTelegramCommandsResponse, GetTelegramCommandsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/telegram-commands'
    });
};

/**
 * Set Telegram bot commands
 * Set bot commands for a Telegram account.
 */
export const setTelegramCommands = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SetTelegramCommandsData, ThrowOnError>) => {
    return (options?.client ?? client).put<SetTelegramCommandsResponse, SetTelegramCommandsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/telegram-commands'
    });
};

/**
 * Delete Telegram bot commands
 */
export const deleteTelegramCommands = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteTelegramCommandsData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteTelegramCommandsResponse, DeleteTelegramCommandsError, ThrowOnError>({
        ...options,
        url: '/v1/accounts/{accountId}/telegram-commands'
    });
};

/**
 * List commented posts
 * Fetch posts with their comment counts from all connected accounts.
 * Aggregates data from multiple accounts in a single API call.
 *
 * **Supported platforms:** Facebook, Instagram, Twitter/X, Bluesky, Threads, YouTube, LinkedIn, Reddit, TikTok (write-only)
 *
 */
export const listInboxComments = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListInboxCommentsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListInboxCommentsResponse, ListInboxCommentsError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments'
    });
};

/**
 * Get post comments
 * Fetch comments for a specific post. Requires accountId query parameter.
 */
export const getInboxPostComments = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<GetInboxPostCommentsData, ThrowOnError>) => {
    return (options?.client ?? client).get<GetInboxPostCommentsResponse, GetInboxPostCommentsError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}'
    });
};

/**
 * Reply to comment
 * Post a reply to a post or specific comment. Requires accountId in request body.
 */
export const replyToInboxPost = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ReplyToInboxPostData, ThrowOnError>) => {
    return (options?.client ?? client).post<ReplyToInboxPostResponse, ReplyToInboxPostError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}'
    });
};

/**
 * Delete comment
 * Delete a comment on a post. Supported by Facebook, Instagram, Bluesky, Reddit, YouTube, LinkedIn, and TikTok.
 * Requires accountId and commentId query parameters.
 *
 */
export const deleteInboxComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteInboxCommentData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteInboxCommentResponse, DeleteInboxCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}'
    });
};

/**
 * Hide comment
 * Hide a comment on a post. Supported by Facebook, Instagram, and Threads.
 * Hidden comments are only visible to the commenter and page admin.
 *
 */
export const hideInboxComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<HideInboxCommentData, ThrowOnError>) => {
    return (options?.client ?? client).post<HideInboxCommentResponse, HideInboxCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}/{commentId}/hide'
    });
};

/**
 * Unhide comment
 * Unhide a previously hidden comment. Supported by Facebook, Instagram, and Threads.
 *
 */
export const unhideInboxComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UnhideInboxCommentData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnhideInboxCommentResponse, UnhideInboxCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}/{commentId}/hide'
    });
};

/**
 * Like comment
 * Like or upvote a comment on a post.
 *
 * **Supported platforms:** Facebook, Twitter/X, Bluesky, Reddit
 *
 * For Bluesky, the `cid` (content identifier) is required in the request body.
 *
 */
export const likeInboxComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<LikeInboxCommentData, ThrowOnError>) => {
    return (options?.client ?? client).post<LikeInboxCommentResponse, LikeInboxCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}/{commentId}/like'
    });
};

/**
 * Unlike comment
 * Remove a like from a comment.
 *
 * **Supported platforms:** Facebook, Twitter/X, Bluesky, Reddit
 *
 * For Bluesky, the `likeUri` query parameter is required.
 *
 */
export const unlikeInboxComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<UnlikeInboxCommentData, ThrowOnError>) => {
    return (options?.client ?? client).delete<UnlikeInboxCommentResponse, UnlikeInboxCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}/{commentId}/like'
    });
};

/**
 * Send private reply
 * Send a private direct message to the author of a comment on your post.
 * This is useful for handling customer inquiries or sensitive matters privately.
 *
 * **Supported platforms:** Instagram, Facebook
 *
 * **Limitations:**
 * - Only ONE private reply per comment (platform API restriction)
 * - Must be sent within 7 days of the comment being posted
 * - Only works for comments on posts owned by the connected account
 * - Text only (no media attachments)
 * - Instagram: message goes to the user's Inbox (if they follow you) or Message Requests (if they don't). Requires `instagram_business_manage_messages` permission.
 * - Facebook: message opens a Messenger conversation with the commenter. Requires `pages_messaging` permission.
 *
 * **Note:** Both permissions are already included in Late's OAuth flow. This does not create a conversation thread until the user replies back.
 *
 */
export const sendPrivateReplyToComment = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<SendPrivateReplyToCommentData, ThrowOnError>) => {
    return (options?.client ?? client).post<SendPrivateReplyToCommentResponse, SendPrivateReplyToCommentError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/comments/{postId}/{commentId}/private-reply'
    });
};

/**
 * List reviews
 * Fetch reviews from all connected Facebook Pages and Google Business accounts.
 * Aggregates data with filtering and sorting options.
 *
 * **Supported platforms:** Facebook, Google Business
 *
 */
export const listInboxReviews = <ThrowOnError extends boolean = false>(options?: OptionsLegacyParser<ListInboxReviewsData, ThrowOnError>) => {
    return (options?.client ?? client).get<ListInboxReviewsResponse, ListInboxReviewsError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/reviews'
    });
};

/**
 * Reply to review
 * Post a reply to a review. Requires accountId in request body.
 */
export const replyToInboxReview = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<ReplyToInboxReviewData, ThrowOnError>) => {
    return (options?.client ?? client).post<ReplyToInboxReviewResponse, ReplyToInboxReviewError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/reviews/{reviewId}/reply'
    });
};

/**
 * Delete review reply
 * Delete a reply to a review (Google Business only). Requires accountId in request body.
 */
export const deleteInboxReviewReply = <ThrowOnError extends boolean = false>(options: OptionsLegacyParser<DeleteInboxReviewReplyData, ThrowOnError>) => {
    return (options?.client ?? client).delete<DeleteInboxReviewReplyResponse, DeleteInboxReviewReplyError, ThrowOnError>({
        ...options,
        url: '/v1/inbox/reviews/{reviewId}/reply'
    });
};